// This file was automatically generated by lmsg
// It checks compatibility in message encoding/decoding between lpd and lnd
// Date: 2019-05-03 02:24:43

extern crate wire;

#[cfg(test)]
mod test{
    use std::io::{Cursor};
    use wire::*;
    use common_types::secp256k1_m::{Data, Signed};
    use binformat::{BinarySD, SerdeVec};


    // Encode/decode compatibility check between:
    // LND message: AcceptChannel
    // LPD message: AcceptChannel
    #[test]
    fn accept_channel_test() {
        let msg_hex = "0021000a00000000000000000000000000000000000000000000000000000000000000000000000000640000000000018a88000000000000271000000000000003e900000002000a000702b33a70f3523c2e3ebf6dfacf801e81f0aaaf245912ab1805c7af4dc0be8684e8021850bc208d6a3d4c7e4e58cbfaa81c78e6d2bef43fd547032e30e35c9c647f4802cde77c6c167775147d8188da10aab0525d47d108b62ee50b5f4e0bc18fe9053703f5556856efebbd68f614c2beb4f1cd472f021abfecf062239783cb444bd2f081034cd543ff7c56296132d1b28b7515fb6690f3637ad62da050f2979fc48c65cfeb02a6b0c2fdd99e93a583ef6d7ae837a7fae6bea7a597196df5cad2bd8bd0776a91";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = AcceptChannel {
            temporary_channel_id: ChannelId::from_hex("000a000000000000000000000000000000000000000000000000000000000000").unwrap(),
            dust_limit: Satoshi::from(100),
            max_htlc_value_in_flight: MilliSatoshi::from(101000),
            chanel_reserve: Satoshi::from(10000),
            htlc_minimum: MilliSatoshi::from(1001),
            minimum_accept_depth: 2,
            csv_delay: CsvDelay::from(10),
            max_accepted_htlc_number: 7,
            keys: ChannelKeys {
                funding: RawPublicKey::from_hex("02b33a70f3523c2e3ebf6dfacf801e81f0aaaf245912ab1805c7af4dc0be8684e8").unwrap(),
                revocation: RawPublicKey::from_hex("021850bc208d6a3d4c7e4e58cbfaa81c78e6d2bef43fd547032e30e35c9c647f48").unwrap(),
                payment: RawPublicKey::from_hex("02cde77c6c167775147d8188da10aab0525d47d108b62ee50b5f4e0bc18fe90537").unwrap(),
                delayed_payment: RawPublicKey::from_hex("03f5556856efebbd68f614c2beb4f1cd472f021abfecf062239783cb444bd2f081").unwrap(),
                htlc: RawPublicKey::from_hex("034cd543ff7c56296132d1b28b7515fb6690f3637ad62da050f2979fc48c65cfeb").unwrap(),
                first_per_commitment: RawPublicKey::from_hex("02a6b0c2fdd99e93a583ef6d7ae837a7fae6bea7a597196df5cad2bd8bd0776a91").unwrap(),
            }
        };
        let wrapped_msg_correct = Message::AcceptChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: AnnounceSignatures
    // LPD message: AnnounceSignatures
    #[test]
    fn announce_signatures_test() {
        let msg_hex = "0103010000000000000000000000000000000000000000000000000000000000000000006400000a00010000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = AnnounceSignatures{
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            short_channel_id: ShortChannelId::from_u64(109951163432961),
            node_signature: RawSignature::from_hex("3023021e030000000000000000000000000000000000000000000000000000000000020100").unwrap(),
            bitcoin_signature: RawSignature::from_hex("3024021f04000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
        };
        let wrapped_msg_correct = Message::AnnounceSignatures(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: ChannelAnnouncement
    // LPD message: AnnouncementChannel
    #[test]
    fn announcement_channel_test() {
        let msg_hex = "010000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000182000b0000000000000000000000000000000000000000000000000000000000000004d2000002006402b6263e1233e3be9df1eefe51018a276ad520e761004abf2363b510628a39695f03c29f36ca1b01dcb0e54ab65393735cd35c6b00ef83be62a9caacd0591178a09302987849539a9a1d563da0a4f49f95054c3c8f5bf25a93bd9644ec4389d141c8860306e7d1019aa7640e7681883696abad760ee36e822c6da8240f1a08599b2a927c";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = SignedRaw {
            signature: RawSignature::from_hex("3023021e030000000000000000000000000000000000000000000000000000000000020100").unwrap(),
            data: SignedRaw {
                signature: RawSignature::from_hex("3022021d0400000000000000000000000000000000000000000000000000000000020100").unwrap(),
                data: SignedRaw {
                    signature: RawSignature::from_hex("3024021f02000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
                    data: SignedRaw {
                        signature: RawSignature::from_hex("3023021e050000000000000000000000000000000000000000000000000000000000020100").unwrap(),
                        data: Data(
                            AnnouncementChannelData {
                                features: RawFeatureVector::from_hex("000182").unwrap(),
                                chain_hash: Hash256::from_hex("000b000000000000000000000000000000000000000000000000000000000000").unwrap(),
                                short_channel_id: ShortChannelId::from_u64(1356797348806756),
                                node_id: (
                                    RawPublicKey::from_hex("02b6263e1233e3be9df1eefe51018a276ad520e761004abf2363b510628a39695f").unwrap(),
                                    RawPublicKey::from_hex("03c29f36ca1b01dcb0e54ab65393735cd35c6b00ef83be62a9caacd0591178a093").unwrap(),
                                ),
                                bitcoin_key: (
                                    RawPublicKey::from_hex("02987849539a9a1d563da0a4f49f95054c3c8f5bf25a93bd9644ec4389d141c886").unwrap(),
                                    RawPublicKey::from_hex("0306e7d1019aa7640e7681883696abad760ee36e822c6da8240f1a08599b2a927c").unwrap(),
                                ),
                            }
                        )
                    }
                }
            }
        };
        let wrapped_msg_correct = Message::AnnouncementChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: ReestablishChannel
    // LPD message: ReestablishChannel
    #[test]
    fn reestablish_channel_test() {
        let msg_hex = "00880100000000000000000000000000000000000000000000000000000000000000000000000000000b00000000000000020002000000000000000000000000000000000000000000000000000000000000025755fbb0933a938a9d2563f46d92a0b96726befade6da326837e8ee2d058982d";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ReestablishChannel {
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            next_local_commitment_number: 11,
            next_remote_revocation_number: 2,
            last_remote_commit_secret: u8_32_from_hex("0002000000000000000000000000000000000000000000000000000000000000").unwrap(),
            local_unrevoked_commit_point: RawPublicKey::from_hex("025755fbb0933a938a9d2563f46d92a0b96726befade6da326837e8ee2d058982d").unwrap(),
        };
        let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: ChannelUpdate
    // LPD message: UpdateChannel
    #[test]
    fn update_channel_test() {
        let msg_hex = "0102000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000064000004000f000f42400101006400000000000003e800000064000000050000000005f5e100";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = Signed {
            signature: RawSignature::from_hex("3023021e030000000000000000000000000000000000000000000000000000000000020100").unwrap(),
            data: Data(
                UpdateChannelData{
                    hash: Hash256::from_hex("0004000000000000000000000000000000000000000000000000000000000000").unwrap(),
                    short_channel_id: ShortChannelId::from_u64(109951163039759),
                    timestamp: 1000000,
                    message_flags: 1,
                    channel_flags: 1,
                    time_lock_delta: 100,
                    htlc_minimum: MilliSatoshi::from(1000),
                    base_fee: 100,
                    fee_rate: 5,
                    htlc_maximum: MilliSatoshi::from(100000000),
                }
            )
        };
        let wrapped_msg_correct = Message::UpdateChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: ClosingSigned
    // LPD message: ClosingSigned
    #[test]
    fn closing_signed_test() {
        let msg_hex = "00270100000000000000000000000000000000000000000000000000000000000000000000000000007b00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ClosingSigned {
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            fee: Satoshi::from(123),
            signature: RawSignature::from_hex("3024021f02000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
        };
        let wrapped_msg_correct = Message::ClosingSigned(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: CommitSig
    // LPD message: CommitmentSigned
    #[test]
    fn commitment_signed_test() {
        let msg_hex = "008401000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = CommitmentSigned {
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            signature: RawSignature::from_hex("3024021f02000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
            htlc_signatures: vec![
                RawSignature::from_hex("3024021f03000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
                RawSignature::from_hex("3022021d0400000000000000000000000000000000000000000000000000000000020100").unwrap(),
            ],
        };
        let wrapped_msg_correct = Message::CommitmentSigned(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: FundingCreated
    // LPD message: FundingCreated
    #[test]
    fn funding_created_test() {
        let msg_hex = "002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = FundingCreated {
            temporary_channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            funding_txid: FundingTxid::from_hex("0000000000000000000000000000000000000000000000000000000005000000").unwrap(),
            output_index: OutputIndex::from_u16(2),
            signature: RawSignature::from_hex("3024021f05000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
        };
        let wrapped_msg_correct = Message::FundingCreated(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: FundingLocked
    // LPD message: FundingLocked
    #[test]
    fn funding_locked_test() {
        let msg_hex = "0024010000000000000000000000000000000000000000000000000000000000000002726b36fdd908423757b596a536c8af2be5f6362be5ed99a5ccfc577afa485b78";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = FundingLocked{
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            next_per_commitment_point: RawPublicKey::from_hex("02726b36fdd908423757b596a536c8af2be5f6362be5ed99a5ccfc577afa485b78").unwrap(),
        };
        let wrapped_msg_correct = Message::FundingLocked(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: FundingSigned
    // LPD message: FundingSigned
    #[test]
    fn funding_signed_test() {
        let msg_hex = "0023000500000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = FundingSigned {
            channel_id: ChannelId::from_hex("0005000000000000000000000000000000000000000000000000000000000000").unwrap(),
            signature: RawSignature::from_hex("3024021f03000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
        };
        let wrapped_msg_correct = Message::FundingSigned(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: GossipTimestampRange
    // LPD message: GossipTimestampRange
    #[test]
    fn gossip_timestamp_range_test() {
        let msg_hex = "0109000b00000000000000000000000000000000000000000000000000000000000005f5e100000004d2";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = GossipTimestampRange {
            chain_hash: Hash256::from_hex("000b000000000000000000000000000000000000000000000000000000000000").unwrap(),
            first_timestamp: 100000000,
            timestamp_range: 1234,
        };
        let wrapped_msg_correct = Message::GossipTimestampRange(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: Init
    // LPD message: Init
    #[test]
    fn init_test() {
        let msg_hex = "001000000001cb";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = Init {
            global_features: RawFeatureVector::from_hex("0000").unwrap(),
            local_features: RawFeatureVector::from_hex("0001cb").unwrap(),
        }
        ;
        let wrapped_msg_correct = Message::Init(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: NodeAnnouncement
    // LPD message: AnnouncementNode
    #[test]
    fn announcement_node_test() {
        let msg_hex = "01010000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000759e2320397dbf550ea25eed223abc15b8adcab3916a8414ecc7a280159ced62e040b0e9e21140a01000000000000000000000000000000000000000000000000000000000000000028017f0000012710010909090904d2010a0a65152b67021fff00000a8885a3000000000000ac1f0b55";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = Signed {
            signature: RawSignature::from_hex("3022021d0100000000000000000000000000000000000000000000000000000000020100").unwrap(),
            data: Data (
                AnnouncementNodeData {
                    features: RawFeatureVector::from_hex("0000").unwrap(),
                    timestamp: 123331122,
                    node_id: RawPublicKey::from_hex("0397dbf550ea25eed223abc15b8adcab3916a8414ecc7a280159ced62e040b0e9e").unwrap(),
                    color: Color::from_u32(554961408),
                    alias: NodeAlias::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
                    address: SerdeVec(vec![
                        Address::from_str("127.0.0.1:10000").unwrap(),
                        Address::from_str("9.9.9.9:1234").unwrap(),
                        Address::from_str("10.10.101.21:11111").unwrap(),
                        Address::from_str("[1fff:0:a88:85a3::ac1f]:2901").unwrap(),
                    ]),
                }
            )
        };
        let wrapped_msg_correct = Message::AnnouncementNode(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: OpenChannel
    // LPD message: OpenChannel
    #[test]
    fn open_channel_test() {
        let msg_hex = "002000000c0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000186a0000000000000303500000000000000c8000000000000271000000000000003e800000000000003e80000000a000f000a035f96b787467ee880ffa8762b3272269a331a3a06dcffa9c33ae5a1df75c4f7e603137856f8752ba97e431b027e0358575c218bb369fc2b10ff0e216dbbb0183b92037339b7ca00a3f18985e1da8dc769bca811e58c7c7a15f1e4490df00f3550e660035f135d2a0c8c3c19a32389d3ccb927e932c9dc51dd90040ad3171d7f33ac79cb0321462f76aa0656d17c08253097c05f8ee83549f4f352a7e1f0c693200b6ac11b0280a006b33a23f2e6e53084cd4a3c4bd2206135b698a92fe4509535cd70763aad01";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = OpenChannel {
            chain_hash: Hash256::from_hex("00000c0000000000000000000000000000000000000000000000000000000000").unwrap(),
            temporary_channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            funding: Satoshi::from(100000),
            push: MilliSatoshi::from(12341),
            dust_limit: Satoshi::from(200),
            max_in_flight: MilliSatoshi::from(10000),
            channel_reserve: Satoshi::from(1000),
            htlc_minimum: MilliSatoshi::from(1000),
            fee: SatoshiPerKiloWeight::from(10),
            csv_delay: CsvDelay::from(15),
            max_accepted_htlc_number: 10,
            keys: ChannelKeys {
                funding: RawPublicKey::from_hex("035f96b787467ee880ffa8762b3272269a331a3a06dcffa9c33ae5a1df75c4f7e6").unwrap(),
                revocation: RawPublicKey::from_hex("03137856f8752ba97e431b027e0358575c218bb369fc2b10ff0e216dbbb0183b92").unwrap(),
                payment: RawPublicKey::from_hex("037339b7ca00a3f18985e1da8dc769bca811e58c7c7a15f1e4490df00f3550e660").unwrap(),
                delayed_payment: RawPublicKey::from_hex("035f135d2a0c8c3c19a32389d3ccb927e932c9dc51dd90040ad3171d7f33ac79cb").unwrap(),
                htlc: RawPublicKey::from_hex("0321462f76aa0656d17c08253097c05f8ee83549f4f352a7e1f0c693200b6ac11b").unwrap(),
                first_per_commitment: RawPublicKey::from_hex("0280a006b33a23f2e6e53084cd4a3c4bd2206135b698a92fe4509535cd70763aad").unwrap(),
            },
            flags: ChannelFlags::from_u8(1),
        };
        let wrapped_msg_correct = Message::OpenChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: Ping
    // LPD message: Ping
    #[test]
    fn ping_test() {
        let msg_hex = "0012000a000401020304";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = Ping {
            pong_length: 10,
            data: hex::decode("01020304").unwrap(),
        };
        let wrapped_msg_correct = Message::Ping(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: Pong
    // LPD message: Pong
    #[test]
    fn pong_test() {
        let msg_hex = "0013000201c8";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = Pong {
            data: hex::decode("01c8").unwrap(),
        };
        let wrapped_msg_correct = Message::Pong(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: QueryChannelRange
    // LPD message: QueryChannelRange
    #[test]
    fn query_channel_range_test() {
        let msg_hex = "010700000b0000000000000000000000000000000000000000000000000000000000000027100000000c";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = QueryChannelRange {
            chain_hash: Hash256::from_hex("00000b0000000000000000000000000000000000000000000000000000000000").unwrap(),
            first_block_height: 10000,
            number_of_blocks: 12,
        };
        let wrapped_msg_correct = Message::QueryChannelRange(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: QueryShortChanIDs
    // LPD message: QueryShortChannelIds
    #[test]
    fn query_short_channel_ids_test() {
        let msg_hex = "01050006000000000000000000000000000000000000000000000000000000000000001900002fbd000001000a003a9800000c0065030d40000005000b";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = QueryShortChannelIds {
            chain_hash: Hash256::from_hex("0006000000000000000000000000000000000000000000000000000000000000").unwrap(),
            ids: ShortChannelIdEncoding::from_u64_vec(0, &vec![
                13437131603116042,
                16492674417426533,
                219902325555527691,
            ]).unwrap(),
        };
        let wrapped_msg_correct = Message::QueryShortChannelIds(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Message encoding is not unique (e.g. it uses zlib) so serialisation test is skipped

    }


    // Encode/decode compatibility check between:
    // LND message: ReplyChannelRange
    // LPD message: ReplyChannelRange
    #[test]
    fn reply_channel_range_test() {
        let msg_hex = "010800000b0000000000000000000000000000000000000000000000000000000000000027100000000c01001900002fbd000001000a003a9800000c0065030d40000005000b";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ReplyChannelRange {
            chain_hash: Hash256::from_hex("00000b0000000000000000000000000000000000000000000000000000000000").unwrap(),
            first_block_height: 10000,
            number_of_blocks: 12,
            complete: 1 != 0,
            encoded_short_ids: ShortChannelIdEncoding::from_u64_vec(0, &vec![
                13437131603116042,
                16492674417426533,
                219902325555527691,
            ]).unwrap(),
        };
        let wrapped_msg_correct = Message::ReplyChannelRange(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Message encoding is not unique (e.g. it uses zlib) so serialisation test is skipped

    }


    // Encode/decode compatibility check between:
    // LND message: RevokeAndAck
    // LPD message: RevokeAndAck
    #[test]
    fn revoke_and_ack_test() {
        let msg_hex = "008501000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000026c15505761178eedf56cd210e134b88cdec455b204760e7aed58ad4b961173f4";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = RevokeAndAck{
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            revocation_preimage: Hash256::from_hex("0002000000000000000000000000000000000000000000000000000000000000").unwrap(),
            next_per_commitment_point: RawPublicKey::from_hex("026c15505761178eedf56cd210e134b88cdec455b204760e7aed58ad4b961173f4").unwrap(),
        };
        let wrapped_msg_correct = Message::RevokeAndAck(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: ReplyShortChanIDsEnd
    // LPD message: ReplyShortChannelIdsEnd
    #[test]
    fn reply_short_channel_ids_end_test() {
        let msg_hex = "0106000700000000000000000000000000000000000000000000000000000000000001";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ReplyShortChannelIdsEnd {
            chain_hash: Hash256::from_hex("0007000000000000000000000000000000000000000000000000000000000000").unwrap(),
            complete: 1 != 0,
        };
        let wrapped_msg_correct = Message::ReplyShortChannelIdsEnd(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: Shutdown
    // LPD message: ShutdownChannel
    #[test]
    fn shutdown_channel_test() {
        let msg_hex = "0026010000000000000000000000000000000000000000000000000000000000000000050102030405";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ShutdownChannel {
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            script: hex::decode("0102030405").unwrap(),
        };
        let wrapped_msg_correct = Message::ShutdownChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: UpdateAddHTLC
    // LPD message: UpdateAddHtlc
    #[test]
    fn update_add_htlc_test() {
        let msg_hex = "0080020000000000000000000000000000000000000000000000000000000000000000000000000003e90000000000018a88007900000000000000000000000000000000000000000000000000000000000000000064000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c8";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = UpdateAddHtlc {
            channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            id: HtlcId::from_u64(1001),
            amount: MilliSatoshi::from(101000),
            payment_hash: Hash256::from_hex("0079000000000000000000000000000000000000000000000000000000000000").unwrap(),
            expiry: 100,
            onion_blob: OnionBlob::from_hex("000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c8").unwrap(),
        };
        let wrapped_msg_correct = Message::UpdateAddHtlc(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: UpdateFailHTLC
    // LPD message: UpdateFailHtlc
    #[test]
    fn update_fail_htlc_test() {
        let msg_hex = "00830400000000000000000000000000000000000000000000000000000000000000000000000000271a000401020105";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = UpdateFailHtlc {
            channel_id: ChannelId::from_hex("0400000000000000000000000000000000000000000000000000000000000000").unwrap(),
            id: HtlcId::from_u64(10010),
            reason: hex::decode("01020105").unwrap(),
        };
        let wrapped_msg_correct = Message::UpdateFailHtlc(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: UpdateFailMalformedHTLC
    // LPD message: UpdateFailMalformedHtlc
    #[test]
    fn update_fail_malformed_htlc_test() {
        let msg_hex = "0087020000000000000000000000000000000000000000000000000000000000000000000000000000640000000500000000000000000000000000000000000000000000000000000000c005";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = UpdateFailMalformedHtlc {
            channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            id: HtlcId::from_u64(100),
            sha256_of_onion: Hash256::from_hex("0000000500000000000000000000000000000000000000000000000000000000").unwrap(),
            failure_code: 49157,
        };
        let wrapped_msg_correct = Message::UpdateFailMalformedHtlc(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: UpdateFee
    // LPD message: UpdateFee
    #[test]
    fn update_fee_test() {
        let msg_hex = "00860200000000000000000000000000000000000000000000000000000000000000000003e9";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = UpdateFee {
            channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            fee: SatoshiPerKiloWeight::from(1001),
        };
        let wrapped_msg_correct = Message::UpdateFee(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


    // Encode/decode compatibility check between:
    // LND message: UpdateFulfillHTLCS
    // LPD message: UpdateFulfillHtlc
    #[test]
    fn update_fulfill_htlc_test() {
        let msg_hex = "0082020000000000000000000000000000000000000000000000000000000000000000000000000000790064000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = UpdateFulfillHtlc {
            channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            id: HtlcId::from_u64(121),
            payment_preimage: Hash256::from_hex("0064000000000000000000000000000000000000000000000000000000000000").unwrap()
        };
        let wrapped_msg_correct = Message::UpdateFulfillHtlc(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }


}
