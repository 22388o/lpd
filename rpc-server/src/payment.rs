// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct SendRequest {
    // message fields
    pub destination: ::std::vec::Vec<u8>,
    pub destination_string: ::std::string::String,
    pub amt: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub payment_request: ::std::string::String,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<super::common::FeeLimit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SendRequest {
    pub fn new() -> SendRequest {
        ::std::default::Default::default()
    }

    // bytes destination = 1;

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::vec::Vec<u8>) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.destination, ::std::vec::Vec::new())
    }

    pub fn get_destination(&self) -> &[u8] {
        &self.destination
    }

    // string destination_string = 2;

    pub fn clear_destination_string(&mut self) {
        self.destination_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_string(&mut self, v: ::std::string::String) {
        self.destination_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_string(&mut self) -> &mut ::std::string::String {
        &mut self.destination_string
    }

    // Take field
    pub fn take_destination_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_string, ::std::string::String::new())
    }

    pub fn get_destination_string(&self) -> &str {
        &self.destination_string
    }

    // .Satoshi amt = 3;

    pub fn clear_amt(&mut self) {
        self.amt.clear();
    }

    pub fn has_amt(&self) -> bool {
        self.amt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: super::common::Satoshi) {
        self.amt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amt(&mut self) -> &mut super::common::Satoshi {
        if self.amt.is_none() {
            self.amt.set_default();
        }
        self.amt.as_mut().unwrap()
    }

    // Take field
    pub fn take_amt(&mut self) -> super::common::Satoshi {
        self.amt.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    pub fn get_amt(&self) -> &super::common::Satoshi {
        self.amt.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }

    // bytes payment_hash = 4;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }

    // string payment_hash_string = 5;

    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }

    // string payment_request = 6;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // int32 final_cltv_delta = 7;

    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }

    // .FeeLimit fee_limit = 8;

    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: super::common::FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut super::common::FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> super::common::FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| super::common::FeeLimit::new())
    }

    pub fn get_fee_limit(&self) -> &super::common::FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| super::common::FeeLimit::default_instance())
    }
}

impl ::protobuf::Message for SendRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.amt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_string)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.destination);
        }
        if !self.destination_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_string);
        }
        if let Some(ref v) = self.amt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_hash_string);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_request);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(7, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_bytes(1, &self.destination)?;
        }
        if !self.destination_string.is_empty() {
            os.write_string(2, &self.destination_string)?;
        }
        if let Some(ref v) = self.amt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(5, &self.payment_hash_string)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(6, &self.payment_request)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(7, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendRequest {
        SendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "destination",
                    |m: &SendRequest| { &m.destination },
                    |m: &mut SendRequest| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination_string",
                    |m: &SendRequest| { &m.destination_string },
                    |m: &mut SendRequest| { &mut m.destination_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "amt",
                    |m: &SendRequest| { &m.amt },
                    |m: &mut SendRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendRequest| { &m.payment_hash },
                    |m: &mut SendRequest| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash_string",
                    |m: &SendRequest| { &m.payment_hash_string },
                    |m: &mut SendRequest| { &mut m.payment_hash_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &SendRequest| { &m.payment_request },
                    |m: &mut SendRequest| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &SendRequest| { &m.final_cltv_delta },
                    |m: &mut SendRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::FeeLimit>>(
                    "fee_limit",
                    |m: &SendRequest| { &m.fee_limit },
                    |m: &mut SendRequest| { &mut m.fee_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendRequest>(
                    "SendRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendRequest,
        };
        unsafe {
            instance.get(SendRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendRequest {
    fn clear(&mut self) {
        self.clear_destination();
        self.clear_destination_string();
        self.clear_amt();
        self.clear_payment_hash();
        self.clear_payment_hash_string();
        self.clear_payment_request();
        self.clear_final_cltv_delta();
        self.clear_fee_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendResponse {
    // message fields
    pub payment_error: ::std::string::String,
    pub payment_preimage: ::std::vec::Vec<u8>,
    pub payment_route: ::protobuf::SingularPtrField<super::common::Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SendResponse {
    pub fn new() -> SendResponse {
        ::std::default::Default::default()
    }

    // string payment_error = 1;

    pub fn clear_payment_error(&mut self) {
        self.payment_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_error(&mut self, v: ::std::string::String) {
        self.payment_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_error(&mut self) -> &mut ::std::string::String {
        &mut self.payment_error
    }

    // Take field
    pub fn take_payment_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_error, ::std::string::String::new())
    }

    pub fn get_payment_error(&self) -> &str {
        &self.payment_error
    }

    // bytes payment_preimage = 2;

    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_preimage, ::std::vec::Vec::new())
    }

    pub fn get_payment_preimage(&self) -> &[u8] {
        &self.payment_preimage
    }

    // .Route payment_route = 3;

    pub fn clear_payment_route(&mut self) {
        self.payment_route.clear();
    }

    pub fn has_payment_route(&self) -> bool {
        self.payment_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_route(&mut self, v: super::common::Route) {
        self.payment_route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_route(&mut self) -> &mut super::common::Route {
        if self.payment_route.is_none() {
            self.payment_route.set_default();
        }
        self.payment_route.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_route(&mut self) -> super::common::Route {
        self.payment_route.take().unwrap_or_else(|| super::common::Route::new())
    }

    pub fn get_payment_route(&self) -> &super::common::Route {
        self.payment_route.as_ref().unwrap_or_else(|| super::common::Route::default_instance())
    }
}

impl ::protobuf::Message for SendResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_preimage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payment_route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_error);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_preimage);
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_error.is_empty() {
            os.write_string(1, &self.payment_error)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_bytes(2, &self.payment_preimage)?;
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendResponse {
        SendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_error",
                    |m: &SendResponse| { &m.payment_error },
                    |m: &mut SendResponse| { &mut m.payment_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_preimage",
                    |m: &SendResponse| { &m.payment_preimage },
                    |m: &mut SendResponse| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Route>>(
                    "payment_route",
                    |m: &SendResponse| { &m.payment_route },
                    |m: &mut SendResponse| { &mut m.payment_route },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendResponse>(
                    "SendResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendResponse,
        };
        unsafe {
            instance.get(SendResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendResponse {
    fn clear(&mut self) {
        self.clear_payment_error();
        self.clear_payment_preimage();
        self.clear_payment_route();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Invoice {
    // message fields
    pub memo: ::std::string::String,
    pub receipt: ::std::vec::Vec<u8>,
    pub r_preimage: ::std::vec::Vec<u8>,
    pub r_hash: ::std::vec::Vec<u8>,
    pub value: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub settled: bool,
    pub creation_date: i64,
    pub settle_date: i64,
    pub payment_request: ::std::string::String,
    pub description_hash: ::std::vec::Vec<u8>,
    pub expiry: i64,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: u64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub private: bool,
    pub add_index: u64,
    pub settle_index: u64,
    pub amt_paid: i64,
    pub amt_paid_sat: i64,
    pub amt_paid_msat: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Invoice {
    pub fn new() -> Invoice {
        ::std::default::Default::default()
    }

    // string memo = 1;

    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.memo, ::std::string::String::new())
    }

    pub fn get_memo(&self) -> &str {
        &self.memo
    }

    // bytes receipt = 2;

    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receipt
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receipt, ::std::vec::Vec::new())
    }

    pub fn get_receipt(&self) -> &[u8] {
        &self.receipt
    }

    // bytes r_preimage = 3;

    pub fn clear_r_preimage(&mut self) {
        self.r_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_preimage
    }

    // Take field
    pub fn take_r_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_preimage, ::std::vec::Vec::new())
    }

    pub fn get_r_preimage(&self) -> &[u8] {
        &self.r_preimage
    }

    // bytes r_hash = 4;

    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }

    // .Satoshi value = 5;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::common::Satoshi) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::common::Satoshi {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::common::Satoshi {
        self.value.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    pub fn get_value(&self) -> &super::common::Satoshi {
        self.value.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }

    // bool settled = 6;

    pub fn clear_settled(&mut self) {
        self.settled = false;
    }

    // Param is passed by value, moved
    pub fn set_settled(&mut self, v: bool) {
        self.settled = v;
    }

    pub fn get_settled(&self) -> bool {
        self.settled
    }

    // int64 creation_date = 7;

    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }

    // int64 settle_date = 8;

    pub fn clear_settle_date(&mut self) {
        self.settle_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_date(&mut self, v: i64) {
        self.settle_date = v;
    }

    pub fn get_settle_date(&self) -> i64 {
        self.settle_date
    }

    // string payment_request = 9;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // bytes description_hash = 10;

    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description_hash, ::std::vec::Vec::new())
    }

    pub fn get_description_hash(&self) -> &[u8] {
        &self.description_hash
    }

    // int64 expiry = 11;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }

    // string fallback_addr = 12;

    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }

    // uint64 cltv_expiry = 13;

    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: u64) {
        self.cltv_expiry = v;
    }

    pub fn get_cltv_expiry(&self) -> u64 {
        self.cltv_expiry
    }

    // repeated .RouteHint route_hints = 14;

    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }

    // bool private = 15;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }

    // uint64 add_index = 16;

    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }

    // uint64 settle_index = 17;

    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }

    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }

    // int64 amt_paid = 18;

    pub fn clear_amt_paid(&mut self) {
        self.amt_paid = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid(&mut self, v: i64) {
        self.amt_paid = v;
    }

    pub fn get_amt_paid(&self) -> i64 {
        self.amt_paid
    }

    // int64 amt_paid_sat = 19;

    pub fn clear_amt_paid_sat(&mut self) {
        self.amt_paid_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_sat(&mut self, v: i64) {
        self.amt_paid_sat = v;
    }

    pub fn get_amt_paid_sat(&self) -> i64 {
        self.amt_paid_sat
    }

    // int64 amt_paid_msat = 20;

    pub fn clear_amt_paid_msat(&mut self) {
        self.amt_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_msat(&mut self, v: i64) {
        self.amt_paid_msat = v;
    }

    pub fn get_amt_paid_msat(&self) -> i64 {
        self.amt_paid_msat
    }
}

impl ::protobuf::Message for Invoice {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.memo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_preimage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.settled = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settle_date = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description_hash)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cltv_expiry = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_sat = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.memo);
        }
        if !self.receipt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.receipt);
        }
        if !self.r_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.r_preimage);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.r_hash);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.settled != false {
            my_size += 2;
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(7, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settle_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.description_hash);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(11, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(13, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.private != false {
            my_size += 2;
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(17, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid != 0 {
            my_size += ::protobuf::rt::value_size(18, self.amt_paid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_sat != 0 {
            my_size += ::protobuf::rt::value_size(19, self.amt_paid_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.amt_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.memo.is_empty() {
            os.write_string(1, &self.memo)?;
        }
        if !self.receipt.is_empty() {
            os.write_bytes(2, &self.receipt)?;
        }
        if !self.r_preimage.is_empty() {
            os.write_bytes(3, &self.r_preimage)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(4, &self.r_hash)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.settled != false {
            os.write_bool(6, self.settled)?;
        }
        if self.creation_date != 0 {
            os.write_int64(7, self.creation_date)?;
        }
        if self.settle_date != 0 {
            os.write_int64(8, self.settle_date)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if !self.description_hash.is_empty() {
            os.write_bytes(10, &self.description_hash)?;
        }
        if self.expiry != 0 {
            os.write_int64(11, self.expiry)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(12, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_uint64(13, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.private != false {
            os.write_bool(15, self.private)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(17, self.settle_index)?;
        }
        if self.amt_paid != 0 {
            os.write_int64(18, self.amt_paid)?;
        }
        if self.amt_paid_sat != 0 {
            os.write_int64(19, self.amt_paid_sat)?;
        }
        if self.amt_paid_msat != 0 {
            os.write_int64(20, self.amt_paid_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Invoice {
        Invoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "memo",
                    |m: &Invoice| { &m.memo },
                    |m: &mut Invoice| { &mut m.memo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receipt",
                    |m: &Invoice| { &m.receipt },
                    |m: &mut Invoice| { &mut m.receipt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_preimage",
                    |m: &Invoice| { &m.r_preimage },
                    |m: &mut Invoice| { &mut m.r_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &Invoice| { &m.r_hash },
                    |m: &mut Invoice| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "value",
                    |m: &Invoice| { &m.value },
                    |m: &mut Invoice| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "settled",
                    |m: &Invoice| { &m.settled },
                    |m: &mut Invoice| { &mut m.settled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Invoice| { &m.creation_date },
                    |m: &mut Invoice| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "settle_date",
                    |m: &Invoice| { &m.settle_date },
                    |m: &mut Invoice| { &mut m.settle_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &Invoice| { &m.payment_request },
                    |m: &mut Invoice| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "description_hash",
                    |m: &Invoice| { &m.description_hash },
                    |m: &mut Invoice| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &Invoice| { &m.expiry },
                    |m: &mut Invoice| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &Invoice| { &m.fallback_addr },
                    |m: &mut Invoice| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cltv_expiry",
                    |m: &Invoice| { &m.cltv_expiry },
                    |m: &mut Invoice| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &Invoice| { &m.route_hints },
                    |m: &mut Invoice| { &mut m.route_hints },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Invoice| { &m.private },
                    |m: &mut Invoice| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &Invoice| { &m.add_index },
                    |m: &mut Invoice| { &mut m.add_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_index",
                    |m: &Invoice| { &m.settle_index },
                    |m: &mut Invoice| { &mut m.settle_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid",
                    |m: &Invoice| { &m.amt_paid },
                    |m: &mut Invoice| { &mut m.amt_paid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_sat",
                    |m: &Invoice| { &m.amt_paid_sat },
                    |m: &mut Invoice| { &mut m.amt_paid_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_msat",
                    |m: &Invoice| { &m.amt_paid_msat },
                    |m: &mut Invoice| { &mut m.amt_paid_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Invoice>(
                    "Invoice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Invoice {
        static mut instance: ::protobuf::lazy::Lazy<Invoice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Invoice,
        };
        unsafe {
            instance.get(Invoice::new)
        }
    }
}

impl ::protobuf::Clear for Invoice {
    fn clear(&mut self) {
        self.clear_memo();
        self.clear_receipt();
        self.clear_r_preimage();
        self.clear_r_hash();
        self.clear_value();
        self.clear_settled();
        self.clear_creation_date();
        self.clear_settle_date();
        self.clear_payment_request();
        self.clear_description_hash();
        self.clear_expiry();
        self.clear_fallback_addr();
        self.clear_cltv_expiry();
        self.clear_route_hints();
        self.clear_private();
        self.clear_add_index();
        self.clear_settle_index();
        self.clear_amt_paid();
        self.clear_amt_paid_sat();
        self.clear_amt_paid_msat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Invoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddInvoiceResponse {
    // message fields
    pub r_hash: ::std::vec::Vec<u8>,
    pub payment_request: ::std::string::String,
    pub add_index: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddInvoiceResponse {
    pub fn new() -> AddInvoiceResponse {
        ::std::default::Default::default()
    }

    // bytes r_hash = 1;

    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }

    // string payment_request = 2;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // uint64 add_index = 16;

    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
}

impl ::protobuf::Message for AddInvoiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.r_hash);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_request);
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash.is_empty() {
            os.write_bytes(1, &self.r_hash)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(2, &self.payment_request)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddInvoiceResponse {
        AddInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &AddInvoiceResponse| { &m.r_hash },
                    |m: &mut AddInvoiceResponse| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &AddInvoiceResponse| { &m.payment_request },
                    |m: &mut AddInvoiceResponse| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &AddInvoiceResponse| { &m.add_index },
                    |m: &mut AddInvoiceResponse| { &mut m.add_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddInvoiceResponse>(
                    "AddInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddInvoiceResponse,
        };
        unsafe {
            instance.get(AddInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddInvoiceResponse {
    fn clear(&mut self) {
        self.clear_r_hash();
        self.clear_payment_request();
        self.clear_add_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceRequest {
    // message fields
    pub pending_only: bool,
    pub index_offset: u64,
    pub num_max_invoices: u64,
    pub reversed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListInvoiceRequest {
    pub fn new() -> ListInvoiceRequest {
        ::std::default::Default::default()
    }

    // bool pending_only = 1;

    pub fn clear_pending_only(&mut self) {
        self.pending_only = false;
    }

    // Param is passed by value, moved
    pub fn set_pending_only(&mut self, v: bool) {
        self.pending_only = v;
    }

    pub fn get_pending_only(&self) -> bool {
        self.pending_only
    }

    // uint64 index_offset = 4;

    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u64) {
        self.index_offset = v;
    }

    pub fn get_index_offset(&self) -> u64 {
        self.index_offset
    }

    // uint64 num_max_invoices = 5;

    pub fn clear_num_max_invoices(&mut self) {
        self.num_max_invoices = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_invoices(&mut self, v: u64) {
        self.num_max_invoices = v;
    }

    pub fn get_num_max_invoices(&self) -> u64 {
        self.num_max_invoices
    }

    // bool reversed = 6;

    pub fn clear_reversed(&mut self) {
        self.reversed = false;
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: bool) {
        self.reversed = v;
    }

    pub fn get_reversed(&self) -> bool {
        self.reversed
    }
}

impl ::protobuf::Message for ListInvoiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index_offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_max_invoices = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reversed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pending_only != false {
            my_size += 2;
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_invoices != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_max_invoices, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reversed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.pending_only != false {
            os.write_bool(1, self.pending_only)?;
        }
        if self.index_offset != 0 {
            os.write_uint64(4, self.index_offset)?;
        }
        if self.num_max_invoices != 0 {
            os.write_uint64(5, self.num_max_invoices)?;
        }
        if self.reversed != false {
            os.write_bool(6, self.reversed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceRequest {
        ListInvoiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pending_only",
                    |m: &ListInvoiceRequest| { &m.pending_only },
                    |m: &mut ListInvoiceRequest| { &mut m.pending_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "index_offset",
                    |m: &ListInvoiceRequest| { &m.index_offset },
                    |m: &mut ListInvoiceRequest| { &mut m.index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_max_invoices",
                    |m: &ListInvoiceRequest| { &m.num_max_invoices },
                    |m: &mut ListInvoiceRequest| { &mut m.num_max_invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reversed",
                    |m: &ListInvoiceRequest| { &m.reversed },
                    |m: &mut ListInvoiceRequest| { &mut m.reversed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceRequest>(
                    "ListInvoiceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceRequest,
        };
        unsafe {
            instance.get(ListInvoiceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceRequest {
    fn clear(&mut self) {
        self.clear_pending_only();
        self.clear_index_offset();
        self.clear_num_max_invoices();
        self.clear_reversed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceResponse {
    // message fields
    pub invoices: ::protobuf::RepeatedField<Invoice>,
    pub last_index_offset: u64,
    pub first_index_offset: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListInvoiceResponse {
    pub fn new() -> ListInvoiceResponse {
        ::std::default::Default::default()
    }

    // repeated .Invoice invoices = 1;

    pub fn clear_invoices(&mut self) {
        self.invoices.clear();
    }

    // Param is passed by value, moved
    pub fn set_invoices(&mut self, v: ::protobuf::RepeatedField<Invoice>) {
        self.invoices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invoices(&mut self) -> &mut ::protobuf::RepeatedField<Invoice> {
        &mut self.invoices
    }

    // Take field
    pub fn take_invoices(&mut self) -> ::protobuf::RepeatedField<Invoice> {
        ::std::mem::replace(&mut self.invoices, ::protobuf::RepeatedField::new())
    }

    pub fn get_invoices(&self) -> &[Invoice] {
        &self.invoices
    }

    // uint64 last_index_offset = 2;

    pub fn clear_last_index_offset(&mut self) {
        self.last_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_index_offset(&mut self, v: u64) {
        self.last_index_offset = v;
    }

    pub fn get_last_index_offset(&self) -> u64 {
        self.last_index_offset
    }

    // uint64 first_index_offset = 3;

    pub fn clear_first_index_offset(&mut self) {
        self.first_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_index_offset(&mut self, v: u64) {
        self.first_index_offset = v;
    }

    pub fn get_first_index_offset(&self) -> u64 {
        self.first_index_offset
    }
}

impl ::protobuf::Message for ListInvoiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.invoices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invoices)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.first_index_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invoices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.first_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invoices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_index_offset != 0 {
            os.write_uint64(2, self.last_index_offset)?;
        }
        if self.first_index_offset != 0 {
            os.write_uint64(3, self.first_index_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceResponse {
        ListInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Invoice>>(
                    "invoices",
                    |m: &ListInvoiceResponse| { &m.invoices },
                    |m: &mut ListInvoiceResponse| { &mut m.invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "last_index_offset",
                    |m: &ListInvoiceResponse| { &m.last_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.last_index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "first_index_offset",
                    |m: &ListInvoiceResponse| { &m.first_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.first_index_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceResponse>(
                    "ListInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceResponse,
        };
        unsafe {
            instance.get(ListInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceResponse {
    fn clear(&mut self) {
        self.clear_invoices();
        self.clear_last_index_offset();
        self.clear_first_index_offset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentList {
    // message fields
    pub payments: ::protobuf::RepeatedField<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PaymentList {
    pub fn new() -> PaymentList {
        ::std::default::Default::default()
    }

    // repeated .Payment payments = 1;

    pub fn clear_payments(&mut self) {
        self.payments.clear();
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: ::protobuf::RepeatedField<Payment>) {
        self.payments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payments(&mut self) -> &mut ::protobuf::RepeatedField<Payment> {
        &mut self.payments
    }

    // Take field
    pub fn take_payments(&mut self) -> ::protobuf::RepeatedField<Payment> {
        ::std::mem::replace(&mut self.payments, ::protobuf::RepeatedField::new())
    }

    pub fn get_payments(&self) -> &[Payment] {
        &self.payments
    }
}

impl ::protobuf::Message for PaymentList {
    fn is_initialized(&self) -> bool {
        for v in &self.payments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentList {
        PaymentList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payment>>(
                    "payments",
                    |m: &PaymentList| { &m.payments },
                    |m: &mut PaymentList| { &mut m.payments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentList>(
                    "PaymentList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentList {
        static mut instance: ::protobuf::lazy::Lazy<PaymentList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentList,
        };
        unsafe {
            instance.get(PaymentList::new)
        }
    }
}

impl ::protobuf::Clear for PaymentList {
    fn clear(&mut self) {
        self.clear_payments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payment {
    // message fields
    pub payment_hash: ::std::string::String,
    pub value: i64,
    pub creation_date: i64,
    pub path: ::protobuf::RepeatedField<::std::string::String>,
    pub fee: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub payment_preimage: ::std::string::String,
    pub value_sat: ::protobuf::SingularPtrField<super::common::Satoshi>,
    pub value_msat: ::protobuf::SingularPtrField<super::common::MilliSatoshi>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    // string payment_hash = 1;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }

    // int64 value = 2;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    pub fn get_value(&self) -> i64 {
        self.value
    }

    // int64 creation_date = 3;

    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }

    // repeated string path = 4;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[::std::string::String] {
        &self.path
    }

    // .Satoshi fee = 5;

    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: super::common::Satoshi) {
        self.fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut super::common::Satoshi {
        if self.fee.is_none() {
            self.fee.set_default();
        }
        self.fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee(&mut self) -> super::common::Satoshi {
        self.fee.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    pub fn get_fee(&self) -> &super::common::Satoshi {
        self.fee.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }

    // string payment_preimage = 6;

    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::string::String) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::string::String {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_preimage, ::std::string::String::new())
    }

    pub fn get_payment_preimage(&self) -> &str {
        &self.payment_preimage
    }

    // .Satoshi value_sat = 7;

    pub fn clear_value_sat(&mut self) {
        self.value_sat.clear();
    }

    pub fn has_value_sat(&self) -> bool {
        self.value_sat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_sat(&mut self, v: super::common::Satoshi) {
        self.value_sat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_sat(&mut self) -> &mut super::common::Satoshi {
        if self.value_sat.is_none() {
            self.value_sat.set_default();
        }
        self.value_sat.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_sat(&mut self) -> super::common::Satoshi {
        self.value_sat.take().unwrap_or_else(|| super::common::Satoshi::new())
    }

    pub fn get_value_sat(&self) -> &super::common::Satoshi {
        self.value_sat.as_ref().unwrap_or_else(|| super::common::Satoshi::default_instance())
    }

    // .MilliSatoshi value_msat = 8;

    pub fn clear_value_msat(&mut self) {
        self.value_msat.clear();
    }

    pub fn has_value_msat(&self) -> bool {
        self.value_msat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_msat(&mut self, v: super::common::MilliSatoshi) {
        self.value_msat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_msat(&mut self) -> &mut super::common::MilliSatoshi {
        if self.value_msat.is_none() {
            self.value_msat.set_default();
        }
        self.value_msat.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_msat(&mut self) -> super::common::MilliSatoshi {
        self.value_msat.take().unwrap_or_else(|| super::common::MilliSatoshi::new())
    }

    pub fn get_value_msat(&self) -> &super::common::MilliSatoshi {
        self.value_msat.as_ref().unwrap_or_else(|| super::common::MilliSatoshi::default_instance())
    }
}

impl ::protobuf::Message for Payment {
    fn is_initialized(&self) -> bool {
        for v in &self.fee {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_sat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_msat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_preimage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_sat)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_msat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.fee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_preimage);
        }
        if let Some(ref v) = self.value_sat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value_msat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_string(1, &self.payment_hash)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if self.creation_date != 0 {
            os.write_int64(3, self.creation_date)?;
        }
        for v in &self.path {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.fee.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_string(6, &self.payment_preimage)?;
        }
        if let Some(ref v) = self.value_sat.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value_msat.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &Payment| { &m.payment_hash },
                    |m: &mut Payment| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &Payment| { &m.value },
                    |m: &mut Payment| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Payment| { &m.creation_date },
                    |m: &mut Payment| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &Payment| { &m.path },
                    |m: &mut Payment| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "fee",
                    |m: &Payment| { &m.fee },
                    |m: &mut Payment| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_preimage",
                    |m: &Payment| { &m.payment_preimage },
                    |m: &mut Payment| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Satoshi>>(
                    "value_sat",
                    |m: &Payment| { &m.value_sat },
                    |m: &mut Payment| { &mut m.value_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::MilliSatoshi>>(
                    "value_msat",
                    |m: &Payment| { &m.value_msat },
                    |m: &mut Payment| { &mut m.value_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Payment>(
                    "Payment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Payment {
        static mut instance: ::protobuf::lazy::Lazy<Payment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Payment,
        };
        unsafe {
            instance.get(Payment::new)
        }
    }
}

impl ::protobuf::Clear for Payment {
    fn clear(&mut self) {
        self.clear_payment_hash();
        self.clear_value();
        self.clear_creation_date();
        self.clear_path();
        self.clear_fee();
        self.clear_payment_preimage();
        self.clear_value_sat();
        self.clear_value_msat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReqString {
    // message fields
    pub pay_req: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PayReqString {
    pub fn new() -> PayReqString {
        ::std::default::Default::default()
    }

    // string pay_req = 1;

    pub fn clear_pay_req(&mut self) {
        self.pay_req.clear();
    }

    // Param is passed by value, moved
    pub fn set_pay_req(&mut self, v: ::std::string::String) {
        self.pay_req = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pay_req(&mut self) -> &mut ::std::string::String {
        &mut self.pay_req
    }

    // Take field
    pub fn take_pay_req(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pay_req, ::std::string::String::new())
    }

    pub fn get_pay_req(&self) -> &str {
        &self.pay_req
    }
}

impl ::protobuf::Message for PayReqString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pay_req)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pay_req.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pay_req);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pay_req.is_empty() {
            os.write_string(1, &self.pay_req)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReqString {
        PayReqString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pay_req",
                    |m: &PayReqString| { &m.pay_req },
                    |m: &mut PayReqString| { &mut m.pay_req },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReqString>(
                    "PayReqString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReqString {
        static mut instance: ::protobuf::lazy::Lazy<PayReqString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReqString,
        };
        unsafe {
            instance.get(PayReqString::new)
        }
    }
}

impl ::protobuf::Clear for PayReqString {
    fn clear(&mut self) {
        self.clear_pay_req();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReqString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReqString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReq {
    // message fields
    pub destination: ::std::string::String,
    pub payment_hash: ::std::string::String,
    pub num_satoshis: i64,
    pub timestamp: i64,
    pub expiry: i64,
    pub description: ::std::string::String,
    pub description_hash: ::std::string::String,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: i64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PayReq {
    pub fn new() -> PayReq {
        ::std::default::Default::default()
    }

    // string destination = 1;

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    pub fn get_destination(&self) -> &str {
        &self.destination
    }

    // string payment_hash = 2;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }

    // int64 num_satoshis = 3;

    pub fn clear_num_satoshis(&mut self) {
        self.num_satoshis = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_satoshis(&mut self, v: i64) {
        self.num_satoshis = v;
    }

    pub fn get_num_satoshis(&self) -> i64 {
        self.num_satoshis
    }

    // int64 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }

    // int64 expiry = 5;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }

    // string description = 6;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string description_hash = 7;

    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::string::String) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::string::String {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description_hash, ::std::string::String::new())
    }

    pub fn get_description_hash(&self) -> &str {
        &self.description_hash
    }

    // string fallback_addr = 8;

    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }

    // int64 cltv_expiry = 9;

    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: i64) {
        self.cltv_expiry = v;
    }

    pub fn get_cltv_expiry(&self) -> i64 {
        self.cltv_expiry
    }

    // repeated .RouteHint route_hints = 10;

    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
}

impl ::protobuf::Message for PayReq {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_satoshis = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description_hash)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cltv_expiry = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash);
        }
        if self.num_satoshis != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_satoshis, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description_hash);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_string(2, &self.payment_hash)?;
        }
        if self.num_satoshis != 0 {
            os.write_int64(3, self.num_satoshis)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        if self.expiry != 0 {
            os.write_int64(5, self.expiry)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.description_hash.is_empty() {
            os.write_string(7, &self.description_hash)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(8, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_int64(9, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReq {
        PayReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination",
                    |m: &PayReq| { &m.destination },
                    |m: &mut PayReq| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &PayReq| { &m.payment_hash },
                    |m: &mut PayReq| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "num_satoshis",
                    |m: &PayReq| { &m.num_satoshis },
                    |m: &mut PayReq| { &mut m.num_satoshis },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &PayReq| { &m.timestamp },
                    |m: &mut PayReq| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &PayReq| { &m.expiry },
                    |m: &mut PayReq| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PayReq| { &m.description },
                    |m: &mut PayReq| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description_hash",
                    |m: &PayReq| { &m.description_hash },
                    |m: &mut PayReq| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &PayReq| { &m.fallback_addr },
                    |m: &mut PayReq| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cltv_expiry",
                    |m: &PayReq| { &m.cltv_expiry },
                    |m: &mut PayReq| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &PayReq| { &m.route_hints },
                    |m: &mut PayReq| { &mut m.route_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReq>(
                    "PayReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReq {
        static mut instance: ::protobuf::lazy::Lazy<PayReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReq,
        };
        unsafe {
            instance.get(PayReq::new)
        }
    }
}

impl ::protobuf::Clear for PayReq {
    fn clear(&mut self) {
        self.clear_destination();
        self.clear_payment_hash();
        self.clear_num_satoshis();
        self.clear_timestamp();
        self.clear_expiry();
        self.clear_description();
        self.clear_description_hash();
        self.clear_fallback_addr();
        self.clear_cltv_expiry();
        self.clear_route_hints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HopHint {
    // message fields
    pub node_id: ::std::string::String,
    pub chan_id: u64,
    pub fee_base_msat: ::protobuf::SingularPtrField<super::common::MilliSatoshi>,
    pub fee_proportional_millionths: u32,
    pub cltv_expiry_delta: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HopHint {
    pub fn new() -> HopHint {
        ::std::default::Default::default()
    }

    // string node_id = 1;

    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }

    // uint64 chan_id = 2;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // .MilliSatoshi fee_base_msat = 3;

    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat.clear();
    }

    pub fn has_fee_base_msat(&self) -> bool {
        self.fee_base_msat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: super::common::MilliSatoshi) {
        self.fee_base_msat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_base_msat(&mut self) -> &mut super::common::MilliSatoshi {
        if self.fee_base_msat.is_none() {
            self.fee_base_msat.set_default();
        }
        self.fee_base_msat.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_base_msat(&mut self) -> super::common::MilliSatoshi {
        self.fee_base_msat.take().unwrap_or_else(|| super::common::MilliSatoshi::new())
    }

    pub fn get_fee_base_msat(&self) -> &super::common::MilliSatoshi {
        self.fee_base_msat.as_ref().unwrap_or_else(|| super::common::MilliSatoshi::default_instance())
    }

    // uint32 fee_proportional_millionths = 4;

    pub fn clear_fee_proportional_millionths(&mut self) {
        self.fee_proportional_millionths = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_proportional_millionths(&mut self, v: u32) {
        self.fee_proportional_millionths = v;
    }

    pub fn get_fee_proportional_millionths(&self) -> u32 {
        self.fee_proportional_millionths
    }

    // uint32 cltv_expiry_delta = 5;

    pub fn clear_cltv_expiry_delta(&mut self) {
        self.cltv_expiry_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry_delta(&mut self, v: u32) {
        self.cltv_expiry_delta = v;
    }

    pub fn get_cltv_expiry_delta(&self) -> u32 {
        self.cltv_expiry_delta
    }
}

impl ::protobuf::Message for HopHint {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_base_msat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_base_msat)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_proportional_millionths = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_expiry_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_base_msat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fee_proportional_millionths != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_proportional_millionths, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_expiry_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_expiry_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if let Some(ref v) = self.fee_base_msat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fee_proportional_millionths != 0 {
            os.write_uint32(4, self.fee_proportional_millionths)?;
        }
        if self.cltv_expiry_delta != 0 {
            os.write_uint32(5, self.cltv_expiry_delta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HopHint {
        HopHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_id",
                    |m: &HopHint| { &m.node_id },
                    |m: &mut HopHint| { &mut m.node_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &HopHint| { &m.chan_id },
                    |m: &mut HopHint| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::MilliSatoshi>>(
                    "fee_base_msat",
                    |m: &HopHint| { &m.fee_base_msat },
                    |m: &mut HopHint| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fee_proportional_millionths",
                    |m: &HopHint| { &m.fee_proportional_millionths },
                    |m: &mut HopHint| { &mut m.fee_proportional_millionths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cltv_expiry_delta",
                    |m: &HopHint| { &m.cltv_expiry_delta },
                    |m: &mut HopHint| { &mut m.cltv_expiry_delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HopHint>(
                    "HopHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HopHint {
        static mut instance: ::protobuf::lazy::Lazy<HopHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HopHint,
        };
        unsafe {
            instance.get(HopHint::new)
        }
    }
}

impl ::protobuf::Clear for HopHint {
    fn clear(&mut self) {
        self.clear_node_id();
        self.clear_chan_id();
        self.clear_fee_base_msat();
        self.clear_fee_proportional_millionths();
        self.clear_cltv_expiry_delta();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HopHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HopHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteHint {
    // message fields
    pub hop_hints: ::protobuf::RepeatedField<HopHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RouteHint {
    pub fn new() -> RouteHint {
        ::std::default::Default::default()
    }

    // repeated .HopHint hop_hints = 1;

    pub fn clear_hop_hints(&mut self) {
        self.hop_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hop_hints(&mut self, v: ::protobuf::RepeatedField<HopHint>) {
        self.hop_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hop_hints(&mut self) -> &mut ::protobuf::RepeatedField<HopHint> {
        &mut self.hop_hints
    }

    // Take field
    pub fn take_hop_hints(&mut self) -> ::protobuf::RepeatedField<HopHint> {
        ::std::mem::replace(&mut self.hop_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_hop_hints(&self) -> &[HopHint] {
        &self.hop_hints
    }
}

impl ::protobuf::Message for RouteHint {
    fn is_initialized(&self) -> bool {
        for v in &self.hop_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hop_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hop_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hop_hints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteHint {
        RouteHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HopHint>>(
                    "hop_hints",
                    |m: &RouteHint| { &m.hop_hints },
                    |m: &mut RouteHint| { &mut m.hop_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteHint>(
                    "RouteHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteHint {
        static mut instance: ::protobuf::lazy::Lazy<RouteHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteHint,
        };
        unsafe {
            instance.get(RouteHint::new)
        }
    }
}

impl ::protobuf::Clear for RouteHint {
    fn clear(&mut self) {
        self.clear_hop_hints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rpayment.proto\x1a\x0ccommon.proto\"\xc8\x02\n\x0bSendRequest\x12\x20\
    \n\x0bdestination\x18\x01\x20\x01(\x0cR\x0bdestination\x12-\n\x12destina\
    tion_string\x18\x02\x20\x01(\tR\x11destinationString\x12\x1a\n\x03amt\
    \x18\x03\x20\x01(\x0b2\x08.SatoshiR\x03amt\x12!\n\x0cpayment_hash\x18\
    \x04\x20\x01(\x0cR\x0bpaymentHash\x12.\n\x13payment_hash_string\x18\x05\
    \x20\x01(\tR\x11paymentHashString\x12'\n\x0fpayment_request\x18\x06\x20\
    \x01(\tR\x0epaymentRequest\x12(\n\x10final_cltv_delta\x18\x07\x20\x01(\
    \x05R\x0efinalCltvDelta\x12&\n\tfee_limit\x18\x08\x20\x01(\x0b2\t.FeeLim\
    itR\x08feeLimit\"\x8e\x01\n\x0cSendResponse\x12$\n\rpayment_error\x18\
    \x01\x20\x01(\tR\rpayment_error\x12*\n\x10payment_preimage\x18\x02\x20\
    \x01(\x0cR\x10payment_preimage\x12,\n\rpayment_route\x18\x03\x20\x01(\
    \x0b2\x06.RouteR\rpayment_route\"\x9b\x05\n\x07Invoice\x12\x12\n\x04memo\
    \x18\x01\x20\x01(\tR\x04memo\x12\x18\n\x07receipt\x18\x02\x20\x01(\x0cR\
    \x07receipt\x12\x1e\n\nr_preimage\x18\x03\x20\x01(\x0cR\nr_preimage\x12\
    \x16\n\x06r_hash\x18\x04\x20\x01(\x0cR\x06r_hash\x12\x1e\n\x05value\x18\
    \x05\x20\x01(\x0b2\x08.SatoshiR\x05value\x12\x18\n\x07settled\x18\x06\
    \x20\x01(\x08R\x07settled\x12$\n\rcreation_date\x18\x07\x20\x01(\x03R\rc\
    reation_date\x12\x20\n\x0bsettle_date\x18\x08\x20\x01(\x03R\x0bsettle_da\
    te\x12(\n\x0fpayment_request\x18\t\x20\x01(\tR\x0fpayment_request\x12*\n\
    \x10description_hash\x18\n\x20\x01(\x0cR\x10description_hash\x12\x16\n\
    \x06expiry\x18\x0b\x20\x01(\x03R\x06expiry\x12$\n\rfallback_addr\x18\x0c\
    \x20\x01(\tR\rfallback_addr\x12\x20\n\x0bcltv_expiry\x18\r\x20\x01(\x04R\
    \x0bcltv_expiry\x12,\n\x0broute_hints\x18\x0e\x20\x03(\x0b2\n.RouteHintR\
    \x0broute_hints\x12\x18\n\x07private\x18\x0f\x20\x01(\x08R\x07private\
    \x12\x1c\n\tadd_index\x18\x10\x20\x01(\x04R\tadd_index\x12\"\n\x0csettle\
    _index\x18\x11\x20\x01(\x04R\x0csettle_index\x12\x1e\n\x08amt_paid\x18\
    \x12\x20\x01(\x03R\x08amt_paidB\x02\x18\x01\x12\"\n\x0camt_paid_sat\x18\
    \x13\x20\x01(\x03R\x0camt_paid_sat\x12$\n\ramt_paid_msat\x18\x14\x20\x01\
    (\x03R\ramt_paid_msat\"t\n\x12AddInvoiceResponse\x12\x16\n\x06r_hash\x18\
    \x01\x20\x01(\x0cR\x06r_hash\x12(\n\x0fpayment_request\x18\x02\x20\x01(\
    \tR\x0fpayment_request\x12\x1c\n\tadd_index\x18\x10\x20\x01(\x04R\tadd_i\
    ndex\"\xa4\x01\n\x12ListInvoiceRequest\x12\"\n\x0cpending_only\x18\x01\
    \x20\x01(\x08R\x0cpending_only\x12\"\n\x0cindex_offset\x18\x04\x20\x01(\
    \x04R\x0cindex_offset\x12*\n\x10num_max_invoices\x18\x05\x20\x01(\x04R\
    \x10num_max_invoices\x12\x1a\n\x08reversed\x18\x06\x20\x01(\x08R\x08reve\
    rsed\"\x99\x01\n\x13ListInvoiceResponse\x12$\n\x08invoices\x18\x01\x20\
    \x03(\x0b2\x08.InvoiceR\x08invoices\x12,\n\x11last_index_offset\x18\x02\
    \x20\x01(\x04R\x11last_index_offset\x12.\n\x12first_index_offset\x18\x03\
    \x20\x01(\x04R\x12first_index_offset\"3\n\x0bPaymentList\x12$\n\x08payme\
    nts\x18\x01\x20\x03(\x0b2\x08.PaymentR\x08payments\"\xa0\x02\n\x07Paymen\
    t\x12\"\n\x0cpayment_hash\x18\x01\x20\x01(\tR\x0cpayment_hash\x12\x18\n\
    \x05value\x18\x02\x20\x01(\x03R\x05valueB\x02\x18\x01\x12$\n\rcreation_d\
    ate\x18\x03\x20\x01(\x03R\rcreation_date\x12\x12\n\x04path\x18\x04\x20\
    \x03(\tR\x04path\x12\x1a\n\x03fee\x18\x05\x20\x01(\x0b2\x08.SatoshiR\x03\
    fee\x12*\n\x10payment_preimage\x18\x06\x20\x01(\tR\x10payment_preimage\
    \x12&\n\tvalue_sat\x18\x07\x20\x01(\x0b2\x08.SatoshiR\tvalue_sat\x12-\n\
    \nvalue_msat\x18\x08\x20\x01(\x0b2\r.MilliSatoshiR\nvalue_msat\"'\n\x0cP\
    ayReqString\x12\x17\n\x07pay_req\x18\x01\x20\x01(\tR\x06payReq\"\xec\x02\
    \n\x06PayReq\x12\x20\n\x0bdestination\x18\x01\x20\x01(\tR\x0bdestination\
    \x12\"\n\x0cpayment_hash\x18\x02\x20\x01(\tR\x0cpayment_hash\x12\"\n\x0c\
    num_satoshis\x18\x03\x20\x01(\x03R\x0cnum_satoshis\x12\x1c\n\ttimestamp\
    \x18\x04\x20\x01(\x03R\ttimestamp\x12\x16\n\x06expiry\x18\x05\x20\x01(\
    \x03R\x06expiry\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescript\
    ion\x12*\n\x10description_hash\x18\x07\x20\x01(\tR\x10description_hash\
    \x12$\n\rfallback_addr\x18\x08\x20\x01(\tR\rfallback_addr\x12\x20\n\x0bc\
    ltv_expiry\x18\t\x20\x01(\x03R\x0bcltv_expiry\x12,\n\x0broute_hints\x18\
    \n\x20\x03(\x0b2\n.RouteHintR\x0broute_hints\"\xe2\x01\n\x07HopHint\x12\
    \x18\n\x07node_id\x18\x01\x20\x01(\tR\x07node_id\x12\x18\n\x07chan_id\
    \x18\x02\x20\x01(\x04R\x07chan_id\x123\n\rfee_base_msat\x18\x03\x20\x01(\
    \x0b2\r.MilliSatoshiR\rfee_base_msat\x12@\n\x1bfee_proportional_milliont\
    hs\x18\x04\x20\x01(\rR\x1bfee_proportional_millionths\x12,\n\x11cltv_exp\
    iry_delta\x18\x05\x20\x01(\rR\x11cltv_expiry_delta\"3\n\tRouteHint\x12&\
    \n\thop_hints\x18\x01\x20\x03(\x0b2\x08.HopHintR\thop_hints2\xff\x01\n\
    \x0ePaymentService\x120\n\x0bSendPayment\x12\x0c.SendRequest\x1a\r.SendR\
    esponse\"\0(\x010\x01\x12-\n\nAddInvoice\x12\x08.Invoice\x1a\x13.AddInvo\
    iceResponse\"\0\x12;\n\x0cListInvoices\x12\x13.ListInvoiceRequest\x1a\
    \x14.ListInvoiceResponse\"\0\x12(\n\x0cDecodePayReq\x12\r.PayReqString\
    \x1a\x07.PayReq\"\0\x12%\n\x0cListPayments\x12\x05.Void\x1a\x0c.PaymentL\
    ist\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
