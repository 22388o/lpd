// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Void {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Void {
    pub fn new() -> Void {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Void {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Void {
        Void::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Void>(
                    "Void",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Void {
        static mut instance: ::protobuf::lazy::Lazy<Void> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Void,
        };
        unsafe {
            instance.get(Void::new)
        }
    }
}

impl ::protobuf::Clear for Void {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Void {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelList {
    // message fields
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelList {
    pub fn new() -> ChannelList {
        ::std::default::Default::default()
    }

    // repeated .Channel channels = 1;

    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
}

impl ::protobuf::Message for ChannelList {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelList {
        ChannelList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                    "channels",
                    |m: &ChannelList| { &m.channels },
                    |m: &mut ChannelList| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelList>(
                    "ChannelList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelList {
        static mut instance: ::protobuf::lazy::Lazy<ChannelList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelList,
        };
        unsafe {
            instance.get(ChannelList::new)
        }
    }
}

impl ::protobuf::Clear for ChannelList {
    fn clear(&mut self) {
        self.clear_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub active: bool,
    pub remote_pubkey: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub chan_id: ::protobuf::SingularPtrField<ChannelId>,
    pub capacity: ::protobuf::SingularPtrField<Satoshi>,
    pub local_balance: ::protobuf::SingularPtrField<Satoshi>,
    pub remote_balance: ::protobuf::SingularPtrField<Satoshi>,
    pub commit_fee: ::protobuf::SingularPtrField<Satoshi>,
    pub commit_weight: i64,
    pub fee_per_kw: ::protobuf::SingularPtrField<Satoshi>,
    pub unsettled_balance: ::protobuf::SingularPtrField<Satoshi>,
    pub total_sent: ::protobuf::SingularPtrField<Satoshi>,
    pub total_received: ::protobuf::SingularPtrField<Satoshi>,
    pub num_updates: u64,
    pub pending_htlcs: ::protobuf::RepeatedField<HTLC>,
    pub csv_delay: u32,
    pub private: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // bool active = 1;

    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    pub fn get_active(&self) -> bool {
        self.active
    }

    // string remote_pubkey = 2;

    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }

    // string channel_point = 3;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }

    // .ChannelId chan_id = 4;

    pub fn clear_chan_id(&mut self) {
        self.chan_id.clear();
    }

    pub fn has_chan_id(&self) -> bool {
        self.chan_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: ChannelId) {
        self.chan_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_id(&mut self) -> &mut ChannelId {
        if self.chan_id.is_none() {
            self.chan_id.set_default();
        }
        self.chan_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_id(&mut self) -> ChannelId {
        self.chan_id.take().unwrap_or_else(|| ChannelId::new())
    }

    pub fn get_chan_id(&self) -> &ChannelId {
        self.chan_id.as_ref().unwrap_or_else(|| ChannelId::default_instance())
    }

    // .Satoshi capacity = 5;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: Satoshi) {
        self.capacity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacity(&mut self) -> &mut Satoshi {
        if self.capacity.is_none() {
            self.capacity.set_default();
        }
        self.capacity.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacity(&mut self) -> Satoshi {
        self.capacity.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_capacity(&self) -> &Satoshi {
        self.capacity.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi local_balance = 6;

    pub fn clear_local_balance(&mut self) {
        self.local_balance.clear();
    }

    pub fn has_local_balance(&self) -> bool {
        self.local_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: Satoshi) {
        self.local_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_balance(&mut self) -> &mut Satoshi {
        if self.local_balance.is_none() {
            self.local_balance.set_default();
        }
        self.local_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_balance(&mut self) -> Satoshi {
        self.local_balance.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_local_balance(&self) -> &Satoshi {
        self.local_balance.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi remote_balance = 7;

    pub fn clear_remote_balance(&mut self) {
        self.remote_balance.clear();
    }

    pub fn has_remote_balance(&self) -> bool {
        self.remote_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: Satoshi) {
        self.remote_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_balance(&mut self) -> &mut Satoshi {
        if self.remote_balance.is_none() {
            self.remote_balance.set_default();
        }
        self.remote_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_balance(&mut self) -> Satoshi {
        self.remote_balance.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_remote_balance(&self) -> &Satoshi {
        self.remote_balance.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi commit_fee = 8;

    pub fn clear_commit_fee(&mut self) {
        self.commit_fee.clear();
    }

    pub fn has_commit_fee(&self) -> bool {
        self.commit_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: Satoshi) {
        self.commit_fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_fee(&mut self) -> &mut Satoshi {
        if self.commit_fee.is_none() {
            self.commit_fee.set_default();
        }
        self.commit_fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_fee(&mut self) -> Satoshi {
        self.commit_fee.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_commit_fee(&self) -> &Satoshi {
        self.commit_fee.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // int64 commit_weight = 9;

    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }

    // .Satoshi fee_per_kw = 10;

    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw.clear();
    }

    pub fn has_fee_per_kw(&self) -> bool {
        self.fee_per_kw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: Satoshi) {
        self.fee_per_kw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_per_kw(&mut self) -> &mut Satoshi {
        if self.fee_per_kw.is_none() {
            self.fee_per_kw.set_default();
        }
        self.fee_per_kw.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_per_kw(&mut self) -> Satoshi {
        self.fee_per_kw.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_fee_per_kw(&self) -> &Satoshi {
        self.fee_per_kw.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi unsettled_balance = 11;

    pub fn clear_unsettled_balance(&mut self) {
        self.unsettled_balance.clear();
    }

    pub fn has_unsettled_balance(&self) -> bool {
        self.unsettled_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsettled_balance(&mut self, v: Satoshi) {
        self.unsettled_balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsettled_balance(&mut self) -> &mut Satoshi {
        if self.unsettled_balance.is_none() {
            self.unsettled_balance.set_default();
        }
        self.unsettled_balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsettled_balance(&mut self) -> Satoshi {
        self.unsettled_balance.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_unsettled_balance(&self) -> &Satoshi {
        self.unsettled_balance.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi total_sent = 12;

    pub fn clear_total_sent(&mut self) {
        self.total_sent.clear();
    }

    pub fn has_total_sent(&self) -> bool {
        self.total_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_sent(&mut self, v: Satoshi) {
        self.total_sent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_sent(&mut self) -> &mut Satoshi {
        if self.total_sent.is_none() {
            self.total_sent.set_default();
        }
        self.total_sent.as_mut().unwrap()
    }

    // Take field
    pub fn take_total_sent(&mut self) -> Satoshi {
        self.total_sent.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_total_sent(&self) -> &Satoshi {
        self.total_sent.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi total_received = 13;

    pub fn clear_total_received(&mut self) {
        self.total_received.clear();
    }

    pub fn has_total_received(&self) -> bool {
        self.total_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_received(&mut self, v: Satoshi) {
        self.total_received = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_received(&mut self) -> &mut Satoshi {
        if self.total_received.is_none() {
            self.total_received.set_default();
        }
        self.total_received.as_mut().unwrap()
    }

    // Take field
    pub fn take_total_received(&mut self) -> Satoshi {
        self.total_received.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_total_received(&self) -> &Satoshi {
        self.total_received.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // uint64 num_updates = 14;

    pub fn clear_num_updates(&mut self) {
        self.num_updates = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_updates(&mut self, v: u64) {
        self.num_updates = v;
    }

    pub fn get_num_updates(&self) -> u64 {
        self.num_updates
    }

    // repeated .HTLC pending_htlcs = 15;

    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<HTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<HTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<HTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_htlcs(&self) -> &[HTLC] {
        &self.pending_htlcs
    }

    // uint32 csv_delay = 16;

    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }

    // bool private = 17;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.capacity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit_fee {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fee_per_kw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsettled_balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total_sent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total_received {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacity)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_balance)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_balance)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_fee)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_per_kw)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsettled_balance)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.total_sent)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.total_received)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_updates = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active != false {
            my_size += 2;
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.remote_pubkey);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.channel_point);
        }
        if let Some(ref v) = self.chan_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.capacity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commit_fee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(9, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_per_kw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsettled_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.total_sent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.total_received.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_updates != 0 {
            my_size += ::protobuf::rt::value_size(14, self.num_updates, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(16, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.active != false {
            os.write_bool(1, self.active)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(2, &self.remote_pubkey)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(3, &self.channel_point)?;
        }
        if let Some(ref v) = self.chan_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.capacity.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_balance.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_balance.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commit_fee.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(9, self.commit_weight)?;
        }
        if let Some(ref v) = self.fee_per_kw.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsettled_balance.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.total_sent.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.total_received.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_updates != 0 {
            os.write_uint64(14, self.num_updates)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.csv_delay != 0 {
            os.write_uint32(16, self.csv_delay)?;
        }
        if self.private != false {
            os.write_bool(17, self.private)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active",
                    |m: &Channel| { &m.active },
                    |m: &mut Channel| { &mut m.active },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_pubkey",
                    |m: &Channel| { &m.remote_pubkey },
                    |m: &mut Channel| { &mut m.remote_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &Channel| { &m.channel_point },
                    |m: &mut Channel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelId>>(
                    "chan_id",
                    |m: &Channel| { &m.chan_id },
                    |m: &mut Channel| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "capacity",
                    |m: &Channel| { &m.capacity },
                    |m: &mut Channel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "local_balance",
                    |m: &Channel| { &m.local_balance },
                    |m: &mut Channel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "remote_balance",
                    |m: &Channel| { &m.remote_balance },
                    |m: &mut Channel| { &mut m.remote_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "commit_fee",
                    |m: &Channel| { &m.commit_fee },
                    |m: &mut Channel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &Channel| { &m.commit_weight },
                    |m: &mut Channel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "fee_per_kw",
                    |m: &Channel| { &m.fee_per_kw },
                    |m: &mut Channel| { &mut m.fee_per_kw },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "unsettled_balance",
                    |m: &Channel| { &m.unsettled_balance },
                    |m: &mut Channel| { &mut m.unsettled_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "total_sent",
                    |m: &Channel| { &m.total_sent },
                    |m: &mut Channel| { &mut m.total_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "total_received",
                    |m: &Channel| { &m.total_received },
                    |m: &mut Channel| { &mut m.total_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_updates",
                    |m: &Channel| { &m.num_updates },
                    |m: &mut Channel| { &mut m.num_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTLC>>(
                    "pending_htlcs",
                    |m: &Channel| { &m.pending_htlcs },
                    |m: &mut Channel| { &mut m.pending_htlcs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "csv_delay",
                    |m: &Channel| { &m.csv_delay },
                    |m: &mut Channel| { &mut m.csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Channel| { &m.private },
                    |m: &mut Channel| { &mut m.private },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Channel>(
                    "Channel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Channel {
        static mut instance: ::protobuf::lazy::Lazy<Channel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Channel,
        };
        unsafe {
            instance.get(Channel::new)
        }
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.clear_active();
        self.clear_remote_pubkey();
        self.clear_channel_point();
        self.clear_chan_id();
        self.clear_capacity();
        self.clear_local_balance();
        self.clear_remote_balance();
        self.clear_commit_fee();
        self.clear_commit_weight();
        self.clear_fee_per_kw();
        self.clear_unsettled_balance();
        self.clear_total_sent();
        self.clear_total_received();
        self.clear_num_updates();
        self.clear_pending_htlcs();
        self.clear_csv_delay();
        self.clear_private();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTLC {
    // message fields
    pub incoming: bool,
    pub amount: ::protobuf::SingularPtrField<MilliSatoshi>,
    pub hash_lock: ::std::vec::Vec<u8>,
    pub expiration_height: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HTLC {
    pub fn new() -> HTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;

    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    pub fn get_incoming(&self) -> bool {
        self.incoming
    }

    // .MilliSatoshi amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: MilliSatoshi) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut MilliSatoshi {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> MilliSatoshi {
        self.amount.take().unwrap_or_else(|| MilliSatoshi::new())
    }

    pub fn get_amount(&self) -> &MilliSatoshi {
        self.amount.as_ref().unwrap_or_else(|| MilliSatoshi::default_instance())
    }

    // bytes hash_lock = 3;

    pub fn clear_hash_lock(&mut self) {
        self.hash_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_lock
    }

    // Take field
    pub fn take_hash_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_lock, ::std::vec::Vec::new())
    }

    pub fn get_hash_lock(&self) -> &[u8] {
        &self.hash_lock
    }

    // uint32 expiration_height = 4;

    pub fn clear_expiration_height(&mut self) {
        self.expiration_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_height(&mut self, v: u32) {
        self.expiration_height = v;
    }

    pub fn get_expiration_height(&self) -> u32 {
        self.expiration_height
    }
}

impl ::protobuf::Message for HTLC {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash_lock);
        }
        if self.expiration_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash_lock.is_empty() {
            os.write_bytes(3, &self.hash_lock)?;
        }
        if self.expiration_height != 0 {
            os.write_uint32(4, self.expiration_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTLC {
        HTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &HTLC| { &m.incoming },
                    |m: &mut HTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MilliSatoshi>>(
                    "amount",
                    |m: &HTLC| { &m.amount },
                    |m: &mut HTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash_lock",
                    |m: &HTLC| { &m.hash_lock },
                    |m: &mut HTLC| { &mut m.hash_lock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiration_height",
                    |m: &HTLC| { &m.expiration_height },
                    |m: &mut HTLC| { &mut m.expiration_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTLC>(
                    "HTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTLC {
        static mut instance: ::protobuf::lazy::Lazy<HTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTLC,
        };
        unsafe {
            instance.get(HTLC::new)
        }
    }
}

impl ::protobuf::Clear for HTLC {
    fn clear(&mut self) {
        self.clear_incoming();
        self.clear_amount();
        self.clear_hash_lock();
        self.clear_expiration_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Satoshi {
    // message fields
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Satoshi {
    pub fn new() -> Satoshi {
        ::std::default::Default::default()
    }

    // uint64 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }

    pub fn get_value(&self) -> u64 {
        self.value
    }
}

impl ::protobuf::Message for Satoshi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint64(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Satoshi {
        Satoshi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &Satoshi| { &m.value },
                    |m: &mut Satoshi| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Satoshi>(
                    "Satoshi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Satoshi {
        static mut instance: ::protobuf::lazy::Lazy<Satoshi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Satoshi,
        };
        unsafe {
            instance.get(Satoshi::new)
        }
    }
}

impl ::protobuf::Clear for Satoshi {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Satoshi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Satoshi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MilliSatoshi {
    // message fields
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MilliSatoshi {
    pub fn new() -> MilliSatoshi {
        ::std::default::Default::default()
    }

    // uint64 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }

    pub fn get_value(&self) -> u64 {
        self.value
    }
}

impl ::protobuf::Message for MilliSatoshi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint64(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MilliSatoshi {
        MilliSatoshi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &MilliSatoshi| { &m.value },
                    |m: &mut MilliSatoshi| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MilliSatoshi>(
                    "MilliSatoshi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MilliSatoshi {
        static mut instance: ::protobuf::lazy::Lazy<MilliSatoshi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MilliSatoshi,
        };
        unsafe {
            instance.get(MilliSatoshi::new)
        }
    }
}

impl ::protobuf::Clear for MilliSatoshi {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MilliSatoshi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MilliSatoshi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelId {
    // message fields
    pub block_height: u32,
    pub index: u32,
    pub output_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelId {
    pub fn new() -> ChannelId {
        ::std::default::Default::default()
    }

    // uint32 block_height = 1;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u32) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> u32 {
        self.block_height
    }

    // uint32 index = 2;

    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    pub fn get_index(&self) -> u32 {
        self.index
    }

    // uint32 output_index = 3;

    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }

    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
}

impl ::protobuf::Message for ChannelId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.block_height != 0 {
            os.write_uint32(1, self.block_height)?;
        }
        if self.index != 0 {
            os.write_uint32(2, self.index)?;
        }
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelId {
        ChannelId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_height",
                    |m: &ChannelId| { &m.block_height },
                    |m: &mut ChannelId| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index",
                    |m: &ChannelId| { &m.index },
                    |m: &mut ChannelId| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &ChannelId| { &m.output_index },
                    |m: &mut ChannelId| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelId>(
                    "ChannelId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelId {
        static mut instance: ::protobuf::lazy::Lazy<ChannelId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelId,
        };
        unsafe {
            instance.get(ChannelId::new)
        }
    }
}

impl ::protobuf::Clear for ChannelId {
    fn clear(&mut self) {
        self.clear_block_height();
        self.clear_index();
        self.clear_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelFilter {
    // message fields
    pub active_only: bool,
    pub inactive_only: bool,
    pub public_only: bool,
    pub private_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelFilter {
    pub fn new() -> ChannelFilter {
        ::std::default::Default::default()
    }

    // bool active_only = 1;

    pub fn clear_active_only(&mut self) {
        self.active_only = false;
    }

    // Param is passed by value, moved
    pub fn set_active_only(&mut self, v: bool) {
        self.active_only = v;
    }

    pub fn get_active_only(&self) -> bool {
        self.active_only
    }

    // bool inactive_only = 2;

    pub fn clear_inactive_only(&mut self) {
        self.inactive_only = false;
    }

    // Param is passed by value, moved
    pub fn set_inactive_only(&mut self, v: bool) {
        self.inactive_only = v;
    }

    pub fn get_inactive_only(&self) -> bool {
        self.inactive_only
    }

    // bool public_only = 3;

    pub fn clear_public_only(&mut self) {
        self.public_only = false;
    }

    // Param is passed by value, moved
    pub fn set_public_only(&mut self, v: bool) {
        self.public_only = v;
    }

    pub fn get_public_only(&self) -> bool {
        self.public_only
    }

    // bool private_only = 4;

    pub fn clear_private_only(&mut self) {
        self.private_only = false;
    }

    // Param is passed by value, moved
    pub fn set_private_only(&mut self, v: bool) {
        self.private_only = v;
    }

    pub fn get_private_only(&self) -> bool {
        self.private_only
    }
}

impl ::protobuf::Message for ChannelFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_only = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inactive_only = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active_only != false {
            my_size += 2;
        }
        if self.inactive_only != false {
            my_size += 2;
        }
        if self.public_only != false {
            my_size += 2;
        }
        if self.private_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.active_only != false {
            os.write_bool(1, self.active_only)?;
        }
        if self.inactive_only != false {
            os.write_bool(2, self.inactive_only)?;
        }
        if self.public_only != false {
            os.write_bool(3, self.public_only)?;
        }
        if self.private_only != false {
            os.write_bool(4, self.private_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelFilter {
        ChannelFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active_only",
                    |m: &ChannelFilter| { &m.active_only },
                    |m: &mut ChannelFilter| { &mut m.active_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inactive_only",
                    |m: &ChannelFilter| { &m.inactive_only },
                    |m: &mut ChannelFilter| { &mut m.inactive_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "public_only",
                    |m: &ChannelFilter| { &m.public_only },
                    |m: &mut ChannelFilter| { &mut m.public_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private_only",
                    |m: &ChannelFilter| { &m.private_only },
                    |m: &mut ChannelFilter| { &mut m.private_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelFilter>(
                    "ChannelFilter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelFilter {
        static mut instance: ::protobuf::lazy::Lazy<ChannelFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelFilter,
        };
        unsafe {
            instance.get(ChannelFilter::new)
        }
    }
}

impl ::protobuf::Clear for ChannelFilter {
    fn clear(&mut self) {
        self.clear_active_only();
        self.clear_inactive_only();
        self.clear_public_only();
        self.clear_private_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenChannelRequest {
    // message fields
    pub node_pubkey: ::std::vec::Vec<u8>,
    pub node_pubkey_string: ::std::string::String,
    pub local_funding_amount: ::protobuf::SingularPtrField<Satoshi>,
    pub push: ::protobuf::SingularPtrField<Satoshi>,
    pub target_conf: i32,
    pub sat_per_byte: ::protobuf::SingularPtrField<Satoshi>,
    pub private: bool,
    pub min_htlc: ::protobuf::SingularPtrField<MilliSatoshi>,
    pub remote_csv_delay: u32,
    pub min_configs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OpenChannelRequest {
    pub fn new() -> OpenChannelRequest {
        ::std::default::Default::default()
    }

    // bytes node_pubkey = 2;

    pub fn clear_node_pubkey(&mut self) {
        self.node_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_pubkey
    }

    // Take field
    pub fn take_node_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_pubkey, ::std::vec::Vec::new())
    }

    pub fn get_node_pubkey(&self) -> &[u8] {
        &self.node_pubkey
    }

    // string node_pubkey_string = 3;

    pub fn clear_node_pubkey_string(&mut self) {
        self.node_pubkey_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey_string(&mut self, v: ::std::string::String) {
        self.node_pubkey_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey_string(&mut self) -> &mut ::std::string::String {
        &mut self.node_pubkey_string
    }

    // Take field
    pub fn take_node_pubkey_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pubkey_string, ::std::string::String::new())
    }

    pub fn get_node_pubkey_string(&self) -> &str {
        &self.node_pubkey_string
    }

    // .Satoshi local_funding_amount = 4;

    pub fn clear_local_funding_amount(&mut self) {
        self.local_funding_amount.clear();
    }

    pub fn has_local_funding_amount(&self) -> bool {
        self.local_funding_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_funding_amount(&mut self, v: Satoshi) {
        self.local_funding_amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_funding_amount(&mut self) -> &mut Satoshi {
        if self.local_funding_amount.is_none() {
            self.local_funding_amount.set_default();
        }
        self.local_funding_amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_funding_amount(&mut self) -> Satoshi {
        self.local_funding_amount.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_local_funding_amount(&self) -> &Satoshi {
        self.local_funding_amount.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // .Satoshi push = 5;

    pub fn clear_push(&mut self) {
        self.push.clear();
    }

    pub fn has_push(&self) -> bool {
        self.push.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push(&mut self, v: Satoshi) {
        self.push = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push(&mut self) -> &mut Satoshi {
        if self.push.is_none() {
            self.push.set_default();
        }
        self.push.as_mut().unwrap()
    }

    // Take field
    pub fn take_push(&mut self) -> Satoshi {
        self.push.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_push(&self) -> &Satoshi {
        self.push.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // int32 target_conf = 6;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // .Satoshi sat_per_byte = 7;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte.clear();
    }

    pub fn has_sat_per_byte(&self) -> bool {
        self.sat_per_byte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: Satoshi) {
        self.sat_per_byte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sat_per_byte(&mut self) -> &mut Satoshi {
        if self.sat_per_byte.is_none() {
            self.sat_per_byte.set_default();
        }
        self.sat_per_byte.as_mut().unwrap()
    }

    // Take field
    pub fn take_sat_per_byte(&mut self) -> Satoshi {
        self.sat_per_byte.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_sat_per_byte(&self) -> &Satoshi {
        self.sat_per_byte.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }

    // bool private = 8;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }

    // .MilliSatoshi min_htlc = 9;

    pub fn clear_min_htlc(&mut self) {
        self.min_htlc.clear();
    }

    pub fn has_min_htlc(&self) -> bool {
        self.min_htlc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: MilliSatoshi) {
        self.min_htlc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_htlc(&mut self) -> &mut MilliSatoshi {
        if self.min_htlc.is_none() {
            self.min_htlc.set_default();
        }
        self.min_htlc.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_htlc(&mut self) -> MilliSatoshi {
        self.min_htlc.take().unwrap_or_else(|| MilliSatoshi::new())
    }

    pub fn get_min_htlc(&self) -> &MilliSatoshi {
        self.min_htlc.as_ref().unwrap_or_else(|| MilliSatoshi::default_instance())
    }

    // uint32 remote_csv_delay = 10;

    pub fn clear_remote_csv_delay(&mut self) {
        self.remote_csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_csv_delay(&mut self, v: u32) {
        self.remote_csv_delay = v;
    }

    pub fn get_remote_csv_delay(&self) -> u32 {
        self.remote_csv_delay
    }

    // int32 min_configs = 11;

    pub fn clear_min_configs(&mut self) {
        self.min_configs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_configs(&mut self, v: i32) {
        self.min_configs = v;
    }

    pub fn get_min_configs(&self) -> i32 {
        self.min_configs
    }

    // bool spend_unconfirmed = 12;

    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }

    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
}

impl ::protobuf::Message for OpenChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.local_funding_amount {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.push {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sat_per_byte {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_htlc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pubkey_string)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_funding_amount)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sat_per_byte)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_htlc)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_csv_delay = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_configs = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.node_pubkey);
        }
        if !self.node_pubkey_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_pubkey_string);
        }
        if let Some(ref v) = self.local_funding_amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.push.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(6, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sat_per_byte.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.private != false {
            my_size += 2;
        }
        if let Some(ref v) = self.min_htlc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.remote_csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(10, self.remote_csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_configs != 0 {
            my_size += ::protobuf::rt::value_size(11, self.min_configs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.node_pubkey.is_empty() {
            os.write_bytes(2, &self.node_pubkey)?;
        }
        if !self.node_pubkey_string.is_empty() {
            os.write_string(3, &self.node_pubkey_string)?;
        }
        if let Some(ref v) = self.local_funding_amount.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.push.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.target_conf != 0 {
            os.write_int32(6, self.target_conf)?;
        }
        if let Some(ref v) = self.sat_per_byte.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.private != false {
            os.write_bool(8, self.private)?;
        }
        if let Some(ref v) = self.min_htlc.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.remote_csv_delay != 0 {
            os.write_uint32(10, self.remote_csv_delay)?;
        }
        if self.min_configs != 0 {
            os.write_int32(11, self.min_configs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(12, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenChannelRequest {
        OpenChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "node_pubkey",
                    |m: &OpenChannelRequest| { &m.node_pubkey },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_pubkey_string",
                    |m: &OpenChannelRequest| { &m.node_pubkey_string },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "local_funding_amount",
                    |m: &OpenChannelRequest| { &m.local_funding_amount },
                    |m: &mut OpenChannelRequest| { &mut m.local_funding_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "push",
                    |m: &OpenChannelRequest| { &m.push },
                    |m: &mut OpenChannelRequest| { &mut m.push },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &OpenChannelRequest| { &m.target_conf },
                    |m: &mut OpenChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "sat_per_byte",
                    |m: &OpenChannelRequest| { &m.sat_per_byte },
                    |m: &mut OpenChannelRequest| { &mut m.sat_per_byte },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &OpenChannelRequest| { &m.private },
                    |m: &mut OpenChannelRequest| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MilliSatoshi>>(
                    "min_htlc",
                    |m: &OpenChannelRequest| { &m.min_htlc },
                    |m: &mut OpenChannelRequest| { &mut m.min_htlc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_csv_delay",
                    |m: &OpenChannelRequest| { &m.remote_csv_delay },
                    |m: &mut OpenChannelRequest| { &mut m.remote_csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "min_configs",
                    |m: &OpenChannelRequest| { &m.min_configs },
                    |m: &mut OpenChannelRequest| { &mut m.min_configs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spend_unconfirmed",
                    |m: &OpenChannelRequest| { &m.spend_unconfirmed },
                    |m: &mut OpenChannelRequest| { &mut m.spend_unconfirmed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenChannelRequest>(
                    "OpenChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<OpenChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenChannelRequest,
        };
        unsafe {
            instance.get(OpenChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for OpenChannelRequest {
    fn clear(&mut self) {
        self.clear_node_pubkey();
        self.clear_node_pubkey_string();
        self.clear_local_funding_amount();
        self.clear_push();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.clear_private();
        self.clear_min_htlc();
        self.clear_remote_csv_delay();
        self.clear_min_configs();
        self.clear_spend_unconfirmed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub force: bool,
    pub target_conf: i32,
    pub sat_per_byte: ::protobuf::SingularPtrField<Satoshi>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CloseChannelRequest {
    pub fn new() -> CloseChannelRequest {
        ::std::default::Default::default()
    }

    // .ChannelPoint channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }

    // bool force = 2;

    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    pub fn get_force(&self) -> bool {
        self.force
    }

    // int32 target_conf = 3;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // .Satoshi sat_per_byte = 4;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte.clear();
    }

    pub fn has_sat_per_byte(&self) -> bool {
        self.sat_per_byte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: Satoshi) {
        self.sat_per_byte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sat_per_byte(&mut self) -> &mut Satoshi {
        if self.sat_per_byte.is_none() {
            self.sat_per_byte.set_default();
        }
        self.sat_per_byte.as_mut().unwrap()
    }

    // Take field
    pub fn take_sat_per_byte(&mut self) -> Satoshi {
        self.sat_per_byte.take().unwrap_or_else(|| Satoshi::new())
    }

    pub fn get_sat_per_byte(&self) -> &Satoshi {
        self.sat_per_byte.as_ref().unwrap_or_else(|| Satoshi::default_instance())
    }
}

impl ::protobuf::Message for CloseChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sat_per_byte {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sat_per_byte)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.force != false {
            my_size += 2;
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sat_per_byte.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.force != false {
            os.write_bool(2, self.force)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if let Some(ref v) = self.sat_per_byte.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseChannelRequest {
        CloseChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &CloseChannelRequest| { &m.channel_point },
                    |m: &mut CloseChannelRequest| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &CloseChannelRequest| { &m.force },
                    |m: &mut CloseChannelRequest| { &mut m.force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &CloseChannelRequest| { &m.target_conf },
                    |m: &mut CloseChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Satoshi>>(
                    "sat_per_byte",
                    |m: &CloseChannelRequest| { &m.sat_per_byte },
                    |m: &mut CloseChannelRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseChannelRequest>(
                    "CloseChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseChannelRequest,
        };
        unsafe {
            instance.get(CloseChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseChannelRequest {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.clear_force();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelPoint {
    // message fields
    pub output_index: u32,
    // message oneof groups
    pub funding_txid: ::std::option::Option<ChannelPoint_oneof_funding_txid>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum ChannelPoint_oneof_funding_txid {
    funding_txid_bytes(::std::vec::Vec<u8>),
    funding_txid_str(::std::string::String),
}

impl ChannelPoint {
    pub fn new() -> ChannelPoint {
        ::std::default::Default::default()
    }

    // bytes funding_txid_bytes = 1;

    pub fn clear_funding_txid_bytes(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_bytes(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(::std::vec::Vec::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_funding_txid_bytes() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_funding_txid_bytes(&self) -> &[u8] {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v)) => v,
            _ => &[],
        }
    }

    // string funding_txid_str = 2;

    pub fn clear_funding_txid_str(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_str(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_str(&mut self, v: ::std::string::String) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_str(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(::std::string::String::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_str(&mut self) -> ::std::string::String {
        if self.has_funding_txid_str() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_funding_txid_str(&self) -> &str {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref v)) => v,
            _ => "",
        }
    }

    // uint32 output_index = 3;

    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }

    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
}

impl ::protobuf::Message for ChannelPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelPoint {
        ChannelPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "funding_txid_bytes",
                    ChannelPoint::has_funding_txid_bytes,
                    ChannelPoint::get_funding_txid_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "funding_txid_str",
                    ChannelPoint::has_funding_txid_str,
                    ChannelPoint::get_funding_txid_str,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &ChannelPoint| { &m.output_index },
                    |m: &mut ChannelPoint| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelPoint>(
                    "ChannelPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelPoint {
        static mut instance: ::protobuf::lazy::Lazy<ChannelPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelPoint,
        };
        unsafe {
            instance.get(ChannelPoint::new)
        }
    }
}

impl ::protobuf::Clear for ChannelPoint {
    fn clear(&mut self) {
        self.clear_funding_txid_bytes();
        self.clear_funding_txid_str();
        self.clear_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<CloseStatusUpdate_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum CloseStatusUpdate_oneof_update {
    close_pending(PendingUpdate),
    confirmation(ConfirmationUpdate),
    chan_close(ChannelCloseUpdate),
}

impl CloseStatusUpdate {
    pub fn new() -> CloseStatusUpdate {
        ::std::default::Default::default()
    }

    // .PendingUpdate close_pending = 1;

    pub fn clear_close_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_close_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_pending(&mut self) -> PendingUpdate {
        if self.has_close_pending() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    pub fn get_close_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }

    // .ConfirmationUpdate confirmation = 2;

    pub fn clear_confirmation(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_confirmation(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confirmation(&mut self, v: ConfirmationUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confirmation(&mut self) -> &mut ConfirmationUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ConfirmationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confirmation(&mut self) -> ConfirmationUpdate {
        if self.has_confirmation() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfirmationUpdate::new()
        }
    }

    pub fn get_confirmation(&self) -> &ConfirmationUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ref v)) => v,
            _ => ConfirmationUpdate::default_instance(),
        }
    }

    // .ChannelCloseUpdate chan_close = 3;

    pub fn clear_chan_close(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_close(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_close(&mut self, v: ChannelCloseUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_close(&mut self) -> &mut ChannelCloseUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ChannelCloseUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_close(&mut self) -> ChannelCloseUpdate {
        if self.has_chan_close() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseUpdate::new()
        }
    }

    pub fn get_chan_close(&self) -> &ChannelCloseUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) => v,
            _ => ChannelCloseUpdate::default_instance(),
        }
    }
}

impl ::protobuf::Message for CloseStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::confirmation(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::confirmation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::confirmation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStatusUpdate {
        CloseStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "close_pending",
                    CloseStatusUpdate::has_close_pending,
                    CloseStatusUpdate::get_close_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConfirmationUpdate>(
                    "confirmation",
                    CloseStatusUpdate::has_confirmation,
                    CloseStatusUpdate::get_confirmation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseUpdate>(
                    "chan_close",
                    CloseStatusUpdate::has_chan_close,
                    CloseStatusUpdate::get_chan_close,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseStatusUpdate>(
                    "CloseStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CloseStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseStatusUpdate,
        };
        unsafe {
            instance.get(CloseStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CloseStatusUpdate {
    fn clear(&mut self) {
        self.clear_close_pending();
        self.clear_confirmation();
        self.clear_chan_close();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<OpenStatusUpdate_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum OpenStatusUpdate_oneof_update {
    chan_pending(PendingUpdate),
    confirmation(ConfirmationUpdate),
    chan_open(ChannelOpenUpdate),
}

impl OpenStatusUpdate {
    pub fn new() -> OpenStatusUpdate {
        ::std::default::Default::default()
    }

    // .PendingUpdate chan_pending = 1;

    pub fn clear_chan_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_pending(&mut self) -> PendingUpdate {
        if self.has_chan_pending() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    pub fn get_chan_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }

    // .ConfirmationUpdate confirmation = 2;

    pub fn clear_confirmation(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_confirmation(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confirmation(&mut self, v: ConfirmationUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confirmation(&mut self) -> &mut ConfirmationUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ConfirmationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confirmation(&mut self) -> ConfirmationUpdate {
        if self.has_confirmation() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfirmationUpdate::new()
        }
    }

    pub fn get_confirmation(&self) -> &ConfirmationUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ref v)) => v,
            _ => ConfirmationUpdate::default_instance(),
        }
    }

    // .ChannelOpenUpdate chan_open = 3;

    pub fn clear_chan_open(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_open(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_open(&mut self, v: ChannelOpenUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_open(&mut self) -> &mut ChannelOpenUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ChannelOpenUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_open(&mut self) -> ChannelOpenUpdate {
        if self.has_chan_open() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelOpenUpdate::new()
        }
    }

    pub fn get_chan_open(&self) -> &ChannelOpenUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) => v,
            _ => ChannelOpenUpdate::default_instance(),
        }
    }
}

impl ::protobuf::Message for OpenStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::confirmation(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::confirmation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::confirmation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenStatusUpdate {
        OpenStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "chan_pending",
                    OpenStatusUpdate::has_chan_pending,
                    OpenStatusUpdate::get_chan_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConfirmationUpdate>(
                    "confirmation",
                    OpenStatusUpdate::has_confirmation,
                    OpenStatusUpdate::get_confirmation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelOpenUpdate>(
                    "chan_open",
                    OpenStatusUpdate::has_chan_open,
                    OpenStatusUpdate::get_chan_open,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenStatusUpdate>(
                    "OpenStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<OpenStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenStatusUpdate,
        };
        unsafe {
            instance.get(OpenStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for OpenStatusUpdate {
    fn clear(&mut self) {
        self.clear_chan_pending();
        self.clear_confirmation();
        self.clear_chan_open();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingUpdate {
    // message fields
    pub txid: ::std::vec::Vec<u8>,
    pub output_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingUpdate {
    pub fn new() -> PendingUpdate {
        ::std::default::Default::default()
    }

    // bytes txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }

    // uint32 output_index = 2;

    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }

    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
}

impl ::protobuf::Message for PendingUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.output_index != 0 {
            os.write_uint32(2, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingUpdate {
        PendingUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &PendingUpdate| { &m.txid },
                    |m: &mut PendingUpdate| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &PendingUpdate| { &m.output_index },
                    |m: &mut PendingUpdate| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingUpdate>(
                    "PendingUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingUpdate {
        static mut instance: ::protobuf::lazy::Lazy<PendingUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingUpdate,
        };
        unsafe {
            instance.get(PendingUpdate::new)
        }
    }
}

impl ::protobuf::Clear for PendingUpdate {
    fn clear(&mut self) {
        self.clear_txid();
        self.clear_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfirmationUpdate {
    // message fields
    pub block_sha: ::std::vec::Vec<u8>,
    pub block_height: i32,
    pub num_confs_left: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConfirmationUpdate {
    pub fn new() -> ConfirmationUpdate {
        ::std::default::Default::default()
    }

    // bytes block_sha = 1;

    pub fn clear_block_sha(&mut self) {
        self.block_sha.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_sha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_sha
    }

    // Take field
    pub fn take_block_sha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_sha, ::std::vec::Vec::new())
    }

    pub fn get_block_sha(&self) -> &[u8] {
        &self.block_sha
    }

    // int32 block_height = 2;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }

    // uint32 num_confs_left = 3;

    pub fn clear_num_confs_left(&mut self) {
        self.num_confs_left = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confs_left(&mut self, v: u32) {
        self.num_confs_left = v;
    }

    pub fn get_num_confs_left(&self) -> u32 {
        self.num_confs_left
    }
}

impl ::protobuf::Message for ConfirmationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_sha)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_confs_left = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_sha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_sha);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confs_left != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confs_left, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.block_sha.is_empty() {
            os.write_bytes(1, &self.block_sha)?;
        }
        if self.block_height != 0 {
            os.write_int32(2, self.block_height)?;
        }
        if self.num_confs_left != 0 {
            os.write_uint32(3, self.num_confs_left)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfirmationUpdate {
        ConfirmationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_sha",
                    |m: &ConfirmationUpdate| { &m.block_sha },
                    |m: &mut ConfirmationUpdate| { &mut m.block_sha },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "block_height",
                    |m: &ConfirmationUpdate| { &m.block_height },
                    |m: &mut ConfirmationUpdate| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_confs_left",
                    |m: &ConfirmationUpdate| { &m.num_confs_left },
                    |m: &mut ConfirmationUpdate| { &mut m.num_confs_left },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfirmationUpdate>(
                    "ConfirmationUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfirmationUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ConfirmationUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfirmationUpdate,
        };
        unsafe {
            instance.get(ConfirmationUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ConfirmationUpdate {
    fn clear(&mut self) {
        self.clear_block_sha();
        self.clear_block_height();
        self.clear_num_confs_left();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfirmationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfirmationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelOpenUpdate {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelOpenUpdate {
    pub fn new() -> ChannelOpenUpdate {
        ::std::default::Default::default()
    }

    // .ChannelPoint channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
}

impl ::protobuf::Message for ChannelOpenUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelOpenUpdate {
        ChannelOpenUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &ChannelOpenUpdate| { &m.channel_point },
                    |m: &mut ChannelOpenUpdate| { &mut m.channel_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelOpenUpdate>(
                    "ChannelOpenUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelOpenUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelOpenUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelOpenUpdate,
        };
        unsafe {
            instance.get(ChannelOpenUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelOpenUpdate {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelOpenUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCloseUpdate {
    // message fields
    pub closing_txid: ::std::vec::Vec<u8>,
    pub success: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelCloseUpdate {
    pub fn new() -> ChannelCloseUpdate {
        ::std::default::Default::default()
    }

    // bytes closing_txid = 1;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.closing_txid, ::std::vec::Vec::new())
    }

    pub fn get_closing_txid(&self) -> &[u8] {
        &self.closing_txid
    }

    // bool success = 2;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }
}

impl ::protobuf::Message for ChannelCloseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.closing_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.closing_txid);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.closing_txid.is_empty() {
            os.write_bytes(1, &self.closing_txid)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseUpdate {
        ChannelCloseUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "closing_txid",
                    |m: &ChannelCloseUpdate| { &m.closing_txid },
                    |m: &mut ChannelCloseUpdate| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &ChannelCloseUpdate| { &m.success },
                    |m: &mut ChannelCloseUpdate| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelCloseUpdate>(
                    "ChannelCloseUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelCloseUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelCloseUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelCloseUpdate,
        };
        unsafe {
            instance.get(ChannelCloseUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelCloseUpdate {
    fn clear(&mut self) {
        self.clear_closing_txid();
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingHTLC {
    // message fields
    pub incoming: bool,
    pub amount: ::protobuf::SingularPtrField<MilliSatoshi>,
    pub outpoint: ::std::string::String,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub stage: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingHTLC {
    pub fn new() -> PendingHTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;

    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    pub fn get_incoming(&self) -> bool {
        self.incoming
    }

    // .MilliSatoshi amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: MilliSatoshi) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut MilliSatoshi {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> MilliSatoshi {
        self.amount.take().unwrap_or_else(|| MilliSatoshi::new())
    }

    pub fn get_amount(&self) -> &MilliSatoshi {
        self.amount.as_ref().unwrap_or_else(|| MilliSatoshi::default_instance())
    }

    // string outpoint = 3;

    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: ::std::string::String) {
        self.outpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut ::std::string::String {
        &mut self.outpoint
    }

    // Take field
    pub fn take_outpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outpoint, ::std::string::String::new())
    }

    pub fn get_outpoint(&self) -> &str {
        &self.outpoint
    }

    // uint32 maturity_height = 4;

    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }

    // int32 blocks_til_maturity = 5;

    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }

    // uint32 stage = 6;

    pub fn clear_stage(&mut self) {
        self.stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = v;
    }

    pub fn get_stage(&self) -> u32 {
        self.stage
    }
}

impl ::protobuf::Message for PendingHTLC {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.outpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.outpoint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stage != 0 {
            my_size += ::protobuf::rt::value_size(6, self.stage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.outpoint.is_empty() {
            os.write_string(3, &self.outpoint)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.stage != 0 {
            os.write_uint32(6, self.stage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingHTLC {
        PendingHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &PendingHTLC| { &m.incoming },
                    |m: &mut PendingHTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MilliSatoshi>>(
                    "amount",
                    |m: &PendingHTLC| { &m.amount },
                    |m: &mut PendingHTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "outpoint",
                    |m: &PendingHTLC| { &m.outpoint },
                    |m: &mut PendingHTLC| { &mut m.outpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingHTLC| { &m.maturity_height },
                    |m: &mut PendingHTLC| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingHTLC| { &m.blocks_til_maturity },
                    |m: &mut PendingHTLC| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stage",
                    |m: &PendingHTLC| { &m.stage },
                    |m: &mut PendingHTLC| { &mut m.stage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingHTLC>(
                    "PendingHTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingHTLC {
        static mut instance: ::protobuf::lazy::Lazy<PendingHTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingHTLC,
        };
        unsafe {
            instance.get(PendingHTLC::new)
        }
    }
}

impl ::protobuf::Clear for PendingHTLC {
    fn clear(&mut self) {
        self.clear_incoming();
        self.clear_amount();
        self.clear_outpoint();
        self.clear_maturity_height();
        self.clear_blocks_til_maturity();
        self.clear_stage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse {
    // message fields
    pub total_limbo_balance: i64,
    pub pending_open_channels: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>,
    pub pending_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>,
    pub pending_force_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>,
    pub waiting_close_channels: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse {
    pub fn new() -> PendingChannelsResponse {
        ::std::default::Default::default()
    }

    // int64 total_limbo_balance = 1;

    pub fn clear_total_limbo_balance(&mut self) {
        self.total_limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_limbo_balance(&mut self, v: i64) {
        self.total_limbo_balance = v;
    }

    pub fn get_total_limbo_balance(&self) -> i64 {
        self.total_limbo_balance
    }

    // repeated .PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;

    pub fn clear_pending_open_channels(&mut self) {
        self.pending_open_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_open_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>) {
        self.pending_open_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_open_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        &mut self.pending_open_channels
    }

    // Take field
    pub fn take_pending_open_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        ::std::mem::replace(&mut self.pending_open_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_open_channels(&self) -> &[PendingChannelsResponse_PendingOpenChannel] {
        &self.pending_open_channels
    }

    // repeated .PendingChannelsResponse.ClosedChannel pending_closing_channels = 3;

    pub fn clear_pending_closing_channels(&mut self) {
        self.pending_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>) {
        self.pending_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        &mut self.pending_closing_channels
    }

    // Take field
    pub fn take_pending_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        ::std::mem::replace(&mut self.pending_closing_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_closing_channels(&self) -> &[PendingChannelsResponse_ClosedChannel] {
        &self.pending_closing_channels
    }

    // repeated .PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;

    pub fn clear_pending_force_closing_channels(&mut self) {
        self.pending_force_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_force_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>) {
        self.pending_force_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_force_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        &mut self.pending_force_closing_channels
    }

    // Take field
    pub fn take_pending_force_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        ::std::mem::replace(&mut self.pending_force_closing_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_force_closing_channels(&self) -> &[PendingChannelsResponse_ForceClosedChannel] {
        &self.pending_force_closing_channels
    }

    // repeated .PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;

    pub fn clear_waiting_close_channels(&mut self) {
        self.waiting_close_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_close_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>) {
        self.waiting_close_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_close_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        &mut self.waiting_close_channels
    }

    // Take field
    pub fn take_waiting_close_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        ::std::mem::replace(&mut self.waiting_close_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_waiting_close_channels(&self) -> &[PendingChannelsResponse_WaitingCloseChannel] {
        &self.waiting_close_channels
    }
}

impl ::protobuf::Message for PendingChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_open_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_force_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.waiting_close_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_limbo_balance = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_open_channels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_closing_channels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_force_closing_channels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.waiting_close_channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_open_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_force_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.waiting_close_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total_limbo_balance != 0 {
            os.write_int64(1, self.total_limbo_balance)?;
        }
        for v in &self.pending_open_channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_closing_channels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_force_closing_channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.waiting_close_channels {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse {
        PendingChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_limbo_balance",
                    |m: &PendingChannelsResponse| { &m.total_limbo_balance },
                    |m: &mut PendingChannelsResponse| { &mut m.total_limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingOpenChannel>>(
                    "pending_open_channels",
                    |m: &PendingChannelsResponse| { &m.pending_open_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_open_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ClosedChannel>>(
                    "pending_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ForceClosedChannel>>(
                    "pending_force_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_force_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_force_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_WaitingCloseChannel>>(
                    "waiting_close_channels",
                    |m: &PendingChannelsResponse| { &m.waiting_close_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.waiting_close_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse>(
                    "PendingChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse,
        };
        unsafe {
            instance.get(PendingChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse {
    fn clear(&mut self) {
        self.clear_total_limbo_balance();
        self.clear_pending_open_channels();
        self.clear_pending_closing_channels();
        self.clear_pending_force_closing_channels();
        self.clear_waiting_close_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingChannel {
    // message fields
    pub remote_node_pub: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_PendingChannel {
    pub fn new() -> PendingChannelsResponse_PendingChannel {
        ::std::default::Default::default()
    }

    // string remote_node_pub = 1;

    pub fn clear_remote_node_pub(&mut self) {
        self.remote_node_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_node_pub(&mut self, v: ::std::string::String) {
        self.remote_node_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_node_pub(&mut self) -> &mut ::std::string::String {
        &mut self.remote_node_pub
    }

    // Take field
    pub fn take_remote_node_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_node_pub, ::std::string::String::new())
    }

    pub fn get_remote_node_pub(&self) -> &str {
        &self.remote_node_pub
    }

    // string channel_point = 2;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }

    // int64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // int64 local_balance = 4;

    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }

    // int64 remote_balance = 5;

    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingChannel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_node_pub)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.remote_node_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.remote_node_pub);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_point);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.remote_node_pub.is_empty() {
            os.write_string(1, &self.remote_node_pub)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(2, &self.channel_point)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(4, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(5, self.remote_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingChannel {
        PendingChannelsResponse_PendingChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_node_pub",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_node_pub },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_node_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.channel_point },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.capacity },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.local_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingChannel>(
                    "PendingChannelsResponse_PendingChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingChannel {
    fn clear(&mut self) {
        self.clear_remote_node_pub();
        self.clear_channel_point();
        self.clear_capacity();
        self.clear_local_balance();
        self.clear_remote_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingOpenChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub confirmation_height: u32,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_PendingOpenChannel {
    pub fn new() -> PendingChannelsResponse_PendingOpenChannel {
        ::std::default::Default::default()
    }

    // .PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // uint32 confirmation_height = 2;

    pub fn clear_confirmation_height(&mut self) {
        self.confirmation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmation_height(&mut self, v: u32) {
        self.confirmation_height = v;
    }

    pub fn get_confirmation_height(&self) -> u32 {
        self.confirmation_height
    }

    // int64 commit_fee = 4;

    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }

    // int64 commit_weight = 5;

    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }

    // int64 fee_per_kw = 6;

    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }

    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingOpenChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.confirmation_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmation_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(6, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmation_height != 0 {
            os.write_uint32(2, self.confirmation_height)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(4, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(5, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(6, self.fee_per_kw)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingOpenChannel {
        PendingChannelsResponse_PendingOpenChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "confirmation_height",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.confirmation_height },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.confirmation_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_fee",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_fee },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_weight },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_kw",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.fee_per_kw },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.fee_per_kw },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingOpenChannel>(
                    "PendingChannelsResponse_PendingOpenChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingOpenChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingOpenChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingOpenChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingOpenChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingOpenChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_confirmation_height();
        self.clear_commit_fee();
        self.clear_commit_weight();
        self.clear_fee_per_kw();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingOpenChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingOpenChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_WaitingCloseChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub limbo_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_WaitingCloseChannel {
    pub fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        ::std::default::Default::default()
    }

    // .PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // int64 limbo_balance = 2;

    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
}

impl ::protobuf::Message for PendingChannelsResponse_WaitingCloseChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(2, self.limbo_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        PendingChannelsResponse_WaitingCloseChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.limbo_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_WaitingCloseChannel>(
                    "PendingChannelsResponse_WaitingCloseChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_WaitingCloseChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_WaitingCloseChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_WaitingCloseChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_WaitingCloseChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_WaitingCloseChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_limbo_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_WaitingCloseChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_WaitingCloseChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_ClosedChannel {
    pub fn new() -> PendingChannelsResponse_ClosedChannel {
        ::std::default::Default::default()
    }

    // .PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // string closing_txid = 2;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ClosedChannel {
        PendingChannelsResponse_ClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.closing_txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ClosedChannel>(
                    "PendingChannelsResponse_ClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ClosedChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_closing_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ForceClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    pub limbo_balance: i64,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub recovered_balance: i64,
    pub pending_htlcs: ::protobuf::RepeatedField<PendingHTLC>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_ForceClosedChannel {
    pub fn new() -> PendingChannelsResponse_ForceClosedChannel {
        ::std::default::Default::default()
    }

    // .PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // string closing_txid = 2;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }

    // int64 limbo_balance = 3;

    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }

    // uint32 maturity_height = 4;

    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }

    // int32 blocks_til_maturity = 5;

    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }

    // int64 recovered_balance = 6;

    pub fn clear_recovered_balance(&mut self) {
        self.recovered_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovered_balance(&mut self, v: i64) {
        self.recovered_balance = v;
    }

    pub fn get_recovered_balance(&self) -> i64 {
        self.recovered_balance
    }

    // repeated .PendingHTLC pending_htlcs = 8;

    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<PendingHTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<PendingHTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<PendingHTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_htlcs(&self) -> &[PendingHTLC] {
        &self.pending_htlcs
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ForceClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recovered_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.recovered_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.recovered_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(3, self.limbo_balance)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.recovered_balance != 0 {
            os.write_int64(6, self.recovered_balance)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ForceClosedChannel {
        PendingChannelsResponse_ForceClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.maturity_height },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.blocks_til_maturity },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "recovered_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.recovered_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.recovered_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingHTLC>>(
                    "pending_htlcs",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.pending_htlcs },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.pending_htlcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ForceClosedChannel>(
                    "PendingChannelsResponse_ForceClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ForceClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ForceClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ForceClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ForceClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ForceClosedChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_closing_txid();
        self.clear_limbo_balance();
        self.clear_maturity_height();
        self.clear_blocks_til_maturity();
        self.clear_recovered_balance();
        self.clear_pending_htlcs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ForceClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ForceClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11src/channel.proto\"\x06\n\x04Void\"3\n\x0bChannelList\x12$\n\x08ch\
    annels\x18\x01\x20\x03(\x0b2\x08.ChannelR\x08channels\"\xa1\x05\n\x07Cha\
    nnel\x12\x16\n\x06active\x18\x01\x20\x01(\x08R\x06active\x12#\n\rremote_\
    pubkey\x18\x02\x20\x01(\tR\x0cremotePubkey\x12#\n\rchannel_point\x18\x03\
    \x20\x01(\tR\x0cchannelPoint\x12#\n\x07chan_id\x18\x04\x20\x01(\x0b2\n.C\
    hannelIdR\x06chanId\x12$\n\x08capacity\x18\x05\x20\x01(\x0b2\x08.Satoshi\
    R\x08capacity\x12-\n\rlocal_balance\x18\x06\x20\x01(\x0b2\x08.SatoshiR\
    \x0clocalBalance\x12/\n\x0eremote_balance\x18\x07\x20\x01(\x0b2\x08.Sato\
    shiR\rremoteBalance\x12'\n\ncommit_fee\x18\x08\x20\x01(\x0b2\x08.Satoshi\
    R\tcommitFee\x12#\n\rcommit_weight\x18\t\x20\x01(\x03R\x0ccommitWeight\
    \x12&\n\nfee_per_kw\x18\n\x20\x01(\x0b2\x08.SatoshiR\x08feePerKw\x125\n\
    \x11unsettled_balance\x18\x0b\x20\x01(\x0b2\x08.SatoshiR\x10unsettledBal\
    ance\x12'\n\ntotal_sent\x18\x0c\x20\x01(\x0b2\x08.SatoshiR\ttotalSent\
    \x12/\n\x0etotal_received\x18\r\x20\x01(\x0b2\x08.SatoshiR\rtotalReceive\
    d\x12\x1f\n\x0bnum_updates\x18\x0e\x20\x01(\x04R\nnumUpdates\x12*\n\rpen\
    ding_htlcs\x18\x0f\x20\x03(\x0b2\x05.HTLCR\x0cpendingHtlcs\x12\x1b\n\tcs\
    v_delay\x18\x10\x20\x01(\rR\x08csvDelay\x12\x18\n\x07private\x18\x11\x20\
    \x01(\x08R\x07private\"\x95\x01\n\x04HTLC\x12\x1a\n\x08incoming\x18\x01\
    \x20\x01(\x08R\x08incoming\x12%\n\x06amount\x18\x02\x20\x01(\x0b2\r.Mill\
    iSatoshiR\x06amount\x12\x1c\n\thash_lock\x18\x03\x20\x01(\x0cR\thash_loc\
    k\x12,\n\x11expiration_height\x18\x04\x20\x01(\rR\x11expiration_height\"\
    \x1f\n\x07Satoshi\x12\x14\n\x05value\x18\x01\x20\x01(\x04R\x05value\"$\n\
    \x0cMilliSatoshi\x12\x14\n\x05value\x18\x01\x20\x01(\x04R\x05value\"g\n\
    \tChannelId\x12!\n\x0cblock_height\x18\x01\x20\x01(\rR\x0bblockHeight\
    \x12\x14\n\x05index\x18\x02\x20\x01(\rR\x05index\x12!\n\x0coutput_index\
    \x18\x03\x20\x01(\rR\x0boutputIndex\"\x99\x01\n\rChannelFilter\x12\x1f\n\
    \x0bactive_only\x18\x01\x20\x01(\x08R\nactiveOnly\x12#\n\rinactive_only\
    \x18\x02\x20\x01(\x08R\x0cinactiveOnly\x12\x1f\n\x0bpublic_only\x18\x03\
    \x20\x01(\x08R\npublicOnly\x12!\n\x0cprivate_only\x18\x04\x20\x01(\x08R\
    \x0bprivateOnly\"\xd7\x03\n\x12OpenChannelRequest\x12\x20\n\x0bnode_pubk\
    ey\x18\x02\x20\x01(\x0cR\x0bnode_pubkey\x12.\n\x12node_pubkey_string\x18\
    \x03\x20\x01(\tR\x12node_pubkey_string\x12<\n\x14local_funding_amount\
    \x18\x04\x20\x01(\x0b2\x08.SatoshiR\x14local_funding_amount\x12\x20\n\
    \x04push\x18\x05\x20\x01(\x0b2\x08.SatoshiR\x08push_sat\x12\x1f\n\x0btar\
    get_conf\x18\x06\x20\x01(\x05R\ntargetConf\x12*\n\x0csat_per_byte\x18\
    \x07\x20\x01(\x0b2\x08.SatoshiR\nsatPerByte\x12\x18\n\x07private\x18\x08\
    \x20\x01(\x08R\x07private\x12.\n\x08min_htlc\x18\t\x20\x01(\x0b2\r.Milli\
    SatoshiR\rmin_htlc_msat\x12*\n\x10remote_csv_delay\x18\n\x20\x01(\rR\x10\
    remote_csv_delay\x12\x1e\n\x0bmin_configs\x18\x0b\x20\x01(\x05R\tmin_con\
    fs\x12,\n\x11spend_unconfirmed\x18\x0c\x20\x01(\x08R\x11spend_unconfirme\
    d\"\xac\x01\n\x13CloseChannelRequest\x122\n\rchannel_point\x18\x01\x20\
    \x01(\x0b2\r.ChannelPointR\x0cchannelPoint\x12\x14\n\x05force\x18\x02\
    \x20\x01(\x08R\x05force\x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\x05R\n\
    targetConf\x12*\n\x0csat_per_byte\x18\x04\x20\x01(\x0b2\x08.SatoshiR\nsa\
    tPerByte\"\xa2\x01\n\x0cChannelPoint\x120\n\x12funding_txid_bytes\x18\
    \x01\x20\x01(\x0cH\0R\x12funding_txid_bytes\x12,\n\x10funding_txid_str\
    \x18\x02\x20\x01(\tH\0R\x10funding_txid_str\x12\"\n\x0coutput_index\x18\
    \x03\x20\x01(\rR\x0coutput_indexB\x0e\n\x0cfunding_txid\"\xc7\x01\n\x11C\
    loseStatusUpdate\x126\n\rclose_pending\x18\x01\x20\x01(\x0b2\x0e.Pending\
    UpdateH\0R\rclose_pending\x129\n\x0cconfirmation\x18\x02\x20\x01(\x0b2\
    \x13.ConfirmationUpdateH\0R\x0cconfirmation\x125\n\nchan_close\x18\x03\
    \x20\x01(\x0b2\x13.ChannelCloseUpdateH\0R\nchan_closeB\x08\n\x06update\"\
    \xc1\x01\n\x10OpenStatusUpdate\x124\n\x0cchan_pending\x18\x01\x20\x01(\
    \x0b2\x0e.PendingUpdateH\0R\x0cchan_pending\x129\n\x0cconfirmation\x18\
    \x02\x20\x01(\x0b2\x13.ConfirmationUpdateH\0R\x0cconfirmation\x122\n\tch\
    an_open\x18\x03\x20\x01(\x0b2\x12.ChannelOpenUpdateH\0R\tchan_openB\x08\
    \n\x06update\"G\n\rPendingUpdate\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\
    \x04txid\x12\"\n\x0coutput_index\x18\x02\x20\x01(\rR\x0coutput_index\"z\
    \n\x12ConfirmationUpdate\x12\x1b\n\tblock_sha\x18\x01\x20\x01(\x0cR\x08b\
    lockSha\x12!\n\x0cblock_height\x18\x02\x20\x01(\x05R\x0bblockHeight\x12$\
    \n\x0enum_confs_left\x18\x03\x20\x01(\rR\x0cnumConfsLeft\"H\n\x11Channel\
    OpenUpdate\x123\n\rchannel_point\x18\x01\x20\x01(\x0b2\r.ChannelPointR\r\
    channel_point\"R\n\x12ChannelCloseUpdate\x12\"\n\x0cclosing_txid\x18\x01\
    \x20\x01(\x0cR\x0cclosing_txid\x12\x18\n\x07success\x18\x02\x20\x01(\x08\
    R\x07success\"\xde\x01\n\x0bPendingHTLC\x12\x1a\n\x08incoming\x18\x01\
    \x20\x01(\x08R\x08incoming\x12%\n\x06amount\x18\x02\x20\x01(\x0b2\r.Mill\
    iSatoshiR\x06amount\x12\x1a\n\x08outpoint\x18\x03\x20\x01(\tR\x08outpoin\
    t\x12(\n\x0fmaturity_height\x18\x04\x20\x01(\rR\x0fmaturity_height\x120\
    \n\x13blocks_til_maturity\x18\x05\x20\x01(\x05R\x13blocks_til_maturity\
    \x12\x14\n\x05stage\x18\x06\x20\x01(\rR\x05stage\"\x86\x0c\n\x17PendingC\
    hannelsResponse\x120\n\x13total_limbo_balance\x18\x01\x20\x01(\x03R\x13t\
    otal_limbo_balance\x12a\n\x15pending_open_channels\x18\x02\x20\x03(\x0b2\
    +.PendingChannelsResponse.PendingOpenChannelR\x15pending_open_channels\
    \x12b\n\x18pending_closing_channels\x18\x03\x20\x03(\x0b2&.PendingChanne\
    lsResponse.ClosedChannelR\x18pending_closing_channels\x12s\n\x1epending_\
    force_closing_channels\x18\x04\x20\x03(\x0b2+.PendingChannelsResponse.Fo\
    rceClosedChannelR\x1epending_force_closing_channels\x12d\n\x16waiting_cl\
    ose_channels\x18\x05\x20\x03(\x0b2,.PendingChannelsResponse.WaitingClose\
    ChannelR\x16waiting_close_channels\x1a\xca\x01\n\x0ePendingChannel\x12(\
    \n\x0fremote_node_pub\x18\x01\x20\x01(\tR\x0fremote_node_pub\x12$\n\rcha\
    nnel_point\x18\x02\x20\x01(\tR\rchannel_point\x12\x1a\n\x08capacity\x18\
    \x03\x20\x01(\x03R\x08capacity\x12$\n\rlocal_balance\x18\x04\x20\x01(\
    \x03R\rlocal_balance\x12&\n\x0eremote_balance\x18\x05\x20\x01(\x03R\x0er\
    emote_balance\x1a\xef\x01\n\x12PendingOpenChannel\x12A\n\x07channel\x18\
    \x01\x20\x01(\x0b2'.PendingChannelsResponse.PendingChannelR\x07channel\
    \x120\n\x13confirmation_height\x18\x02\x20\x01(\rR\x13confirmation_heigh\
    t\x12\x1e\n\ncommit_fee\x18\x04\x20\x01(\x03R\ncommit_fee\x12$\n\rcommit\
    _weight\x18\x05\x20\x01(\x03R\rcommit_weight\x12\x1e\n\nfee_per_kw\x18\
    \x06\x20\x01(\x03R\nfee_per_kw\x1a~\n\x13WaitingCloseChannel\x12A\n\x07c\
    hannel\x18\x01\x20\x01(\x0b2'.PendingChannelsResponse.PendingChannelR\
    \x07channel\x12$\n\rlimbo_balance\x18\x02\x20\x01(\x03R\rlimbo_balance\
    \x1av\n\rClosedChannel\x12A\n\x07channel\x18\x01\x20\x01(\x0b2'.PendingC\
    hannelsResponse.PendingChannelR\x07channel\x12\"\n\x0cclosing_txid\x18\
    \x02\x20\x01(\tR\x0cclosing_txid\x1a\xdf\x02\n\x12ForceClosedChannel\x12\
    A\n\x07channel\x18\x01\x20\x01(\x0b2'.PendingChannelsResponse.PendingCha\
    nnelR\x07channel\x12\"\n\x0cclosing_txid\x18\x02\x20\x01(\tR\x0cclosing_\
    txid\x12$\n\rlimbo_balance\x18\x03\x20\x01(\x03R\rlimbo_balance\x12(\n\
    \x0fmaturity_height\x18\x04\x20\x01(\rR\x0fmaturity_height\x120\n\x13blo\
    cks_til_maturity\x18\x05\x20\x01(\x05R\x13blocks_til_maturity\x12,\n\x11\
    recovered_balance\x18\x06\x20\x01(\x03R\x11recovered_balance\x122\n\rpen\
    ding_htlcs\x18\x08\x20\x03(\x0b2\x0c.PendingHTLCR\rpending_htlcs2\xd1\
    \x01\n\x0eChannelService\x12&\n\x04List\x12\x0e.ChannelFilter\x1a\x0c.Ch\
    annelList\"\0\x12,\n\x07Pending\x12\x05.Void\x1a\x18.PendingChannelsResp\
    onse\"\0\x122\n\x04Open\x12\x13.OpenChannelRequest\x1a\x11.OpenStatusUpd\
    ate\"\00\x01\x125\n\x05Close\x12\x14.CloseChannelRequest\x1a\x12.CloseSt\
    atusUpdate\"\00\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
